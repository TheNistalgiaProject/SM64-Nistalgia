From f3cd1a16197ecf8d7cb6711e7e81bf89ff05f291 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Wed, 6 Nov 2024 19:53:52 -0500
Subject: [PATCH 01/15] Android fixes and misc warning fixes

README: Updated Android compile instructions and properly point to correct repo

TOUCH_CONTROLS can be enabled on PC with SDL2 (works on Windows with a touch screen monitor)

Fixed angle macros on Clang ARM64 (C-Up and possibly other things)

Fixed warnings on termux alongside clear comment on piranha_bubbles crash fix

Improved touch controls, autohide toggle and analog camera
---
 README.md                                     | 12 +++---
 defines.mk                                    |  4 +-
 include/text_options_strings.h.in             |  5 +++
 src/engine/math_util.h                        | 13 ++++---
 src/extras/bettercamera.c                     |  7 ++++
 src/extras/options_menu.c                     | 22 +++++++++++
 src/game/behaviors/piranha_bubbles.inc.c      |  6 ++-
 src/game/camera.c                             |  7 ++++
 src/game/mario_step.c                         |  4 +-
 src/pc/configfile.c                           |  7 ++++
 src/pc/configfile.h                           |  7 +++-
 src/pc/controller/controller_keyboard.c       |  6 +++
 src/pc/controller/controller_sdl2.c           |  6 +++
 src/pc/controller/controller_touchscreen.c    | 28 ++++++++++++--
 src/pc/controller/controller_touchscreen.h    |  3 ++
 .../controller_touchscreen_layouts.inc        |  8 +++-
 src/pc/pc_main.c                              |  3 +-
 tools/assemble_sound.py                       |  2 +-
 tools/audiofile/audiofile.cpp                 | 37 +++++++++----------
 19 files changed, 144 insertions(+), 43 deletions(-)

diff --git a/README.md b/README.md
index 9a1d77213..809f6c55f 100644
--- a/README.md
+++ b/README.md
@@ -25,7 +25,7 @@ Fork of [sm64pc/sm64ex](https://github.com/sm64pc/sm64ex) with additional featur
  ### Clone the repository:
 
  ```sh
- git clone https://github.com/AloXado320/sm64ex-alo
+ git clone https://github.com/AloUltraExt/sm64ex-alo
  cd sm64ex-alo
  ```
  
@@ -33,7 +33,7 @@ Fork of [sm64pc/sm64ex](https://github.com/sm64pc/sm64ex) with additional featur
  
  ```sh
  git config core.fileMode false
- chmod -R 777 .
+ chmod -R 775 .
  ```
  
  ### Copy baserom(s) for asset extraction:
@@ -78,7 +78,7 @@ Fork of [sm64pc/sm64ex](https://github.com/sm64pc/sm64ex) with additional featur
 
   #### Install build dependencies
   ```sh
-  pkg install git wget make python getconf zip apksigner clang binutils
+  pkg install git wget make python getconf zip apksigner clang binutils which libglvnd-dev
   ```
 
   #### Copy in your baserom:
@@ -101,9 +101,11 @@ Fork of [sm64pc/sm64ex](https://github.com/sm64pc/sm64ex) with additional featur
   make -j4
   ```
 
- #### Install apk:
+ #### Copying and Installing apk:
+ 
+ Do this to move the apk to the root of your storage then open it using a file manager.
   ```sh
-  xdg-open build/us_android/sm64.us.f3dex2e.apk
+  cp build/us_android/sm64.us.f3dex2e.apk /sdcard/sm64.us.f3dex2e.apk
   ```
  
 </details>
diff --git a/defines.mk b/defines.mk
index ee4f7c9e9..762961a13 100644
--- a/defines.mk
+++ b/defines.mk
@@ -89,14 +89,14 @@ ifeq ($(EXTERNAL_DATA),1)
   endif
 endif
 
-# Use PC-only exclusive defines
-ifeq ($(TARGET_ANDROID),1)
+ifeq ($(WINDOW_API),SDL2)
   # Check for touch controls
   ifeq ($(TOUCH_CONTROLS),1)
     CUSTOM_C_DEFINES += -DTOUCH_CONTROLS
   endif
 endif
 
+# Use PC-only exclusive defines
 ifeq ($(TARGET_PORT_CONSOLE),0)
 
   # Check for Mouse Option (no DirectX yet)
diff --git a/include/text_options_strings.h.in b/include/text_options_strings.h.in
index c265f429c..1c42de402 100644
--- a/include/text_options_strings.h.in
+++ b/include/text_options_strings.h.in
@@ -11,6 +11,7 @@
 #define TEXT_OPT_VIDEO     _("DISPLAY")
 #define TEXT_OPT_AUDIO     _("SOUND")
 #define TEXT_OPT_SETTINGS  _("SETTINGS")
+#define TEXT_TOUCH_CONTROLS _("TOUCH CONTROLS")
 
 // Markers
 
@@ -97,6 +98,8 @@
 #define TEXT_OPT_DEADZONE  _("STICK DEADZONE")
 #define TEXT_OPT_RUMBLE    _("RUMBLE STRENGTH")
 
+#define TEXT_TOUCH_AUTOHIDE _("AUTOHIDE TOUCH CONTROLS")
+
 #else // VERSION
 
 // Markers
@@ -172,6 +175,8 @@
 #define TEXT_OPT_DEADZONE  _("Stick Deadzone")
 #define TEXT_OPT_RUMBLE    _("Rumble Strength")
 
+#define TEXT_TOUCH_AUTOHIDE _("Autohide Touch Controls")
+
 #endif // VERSION
 
 #endif // TEXT_OPTIONS_STRINGS_H
diff --git a/src/engine/math_util.h b/src/engine/math_util.h
index b78908887..f4c0948d3 100644
--- a/src/engine/math_util.h
+++ b/src/engine/math_util.h
@@ -69,12 +69,13 @@ extern f32 gSineTable[];
 #define RAD_PER_DEG (M_PI / 180.0f)
 #define DEG_PER_RAD (180.0f / M_PI)
 
-#define angle_to_degrees(x) (f32)((Angle)(x) * 360.0f / (f32)0x10000)
-#define degrees_to_angle(x) (Angle)((f32)(x) * (f32)0x10000 / 360.0f)
-#define angle_to_radians(x) (f32)((Angle)(x) * M_PI / (f32)0x8000)
-#define radians_to_angle(x) (Angle)((f32)(x) * (f32)0x8000 / M_PI)
-#define degrees_to_radians(x) (f32)((f32)(x) * M_PI / 180.0f)
-#define radians_to_degrees(x) (f32)((f32)(x) * 180.0f / M_PI)
+// Extra int casts for macros converting to angle to ensure clang ARM64 properly returns these values
+#define angle_to_degrees(x)  ((f32)(((Angle)(x) / 65536.0f) * 360.0f))
+#define degrees_to_angle(x)  ((Angle)((int)(((f32)(x) * 0x10000) / 360)))
+#define angle_to_radians(x)  ((f32)(((Angle)(x) * M_PI) / 0x8000))
+#define radians_to_angle(x)  ((Angle)((int)(((f32)(x) / M_PI) * 0x8000)))
+#define degrees_to_radians(x) ((f32)((f32)(x) * RAD_PER_DEG))
+#define radians_to_degrees(x) ((f32)((f32)(x) * DEG_PER_RAD))
 
 /**
  * Converts an angle in degrees to sm64's s16 angle units. For example, DEGREES(90) == 0x4000
diff --git a/src/extras/bettercamera.c b/src/extras/bettercamera.c
index 8c8704700..5209a2e8d 100644
--- a/src/extras/bettercamera.c
+++ b/src/extras/bettercamera.c
@@ -31,6 +31,9 @@
 #ifdef MOUSE_ACTIONS
 #include "pc/controller/controller_mouse.h"
 #endif
+#ifdef TOUCH_CONTROLS
+#include "pc/controller/controller_touchscreen.h"
+#endif
 
 #include "bettercamera.h"
 #include "puppycam/angles.inc.c"
@@ -1163,6 +1166,10 @@ static void puppycam_vanilla_actions(void) {
 //}
 
 static void puppycam_analogue_stick(void) {
+#ifdef TOUCH_CONTROLS
+    gTouchAnalogCamera = gPuppyCam.options.analogue ? TRUE : FALSE;
+#endif
+
     if (!gPuppyCam.options.analogue)
         return;
 
diff --git a/src/extras/options_menu.c b/src/extras/options_menu.c
index bfa92b9aa..b77ad8a47 100644
--- a/src/extras/options_menu.c
+++ b/src/extras/options_menu.c
@@ -140,6 +140,16 @@ static const u8 optBindStr[][SIZEOPTC(32)] = {
     { TEXT_OPT_DEADZONE },
     { TEXT_OPT_RUMBLE },
 };
+
+#ifdef TOUCH_CONTROLS
+extern struct SubMenu menuTouch;
+
+static const u8 optTouchStr[][SIZEOPTC(32)] = {
+    { TEXT_TOUCH_CONTROLS },
+    { TEXT_TOUCH_AUTOHIDE },
+};
+#endif
+
 #endif
 
 #ifndef TARGET_N64
@@ -197,6 +207,9 @@ static struct Option optsCamera[] = {
 
 #if !defined(TARGET_N64) && !defined(TARGET_PORT_CONSOLE)
 static struct Option optsControls[] = {
+#ifdef TOUCH_CONTROLS
+    DEF_OPT_SUBMENU( optTouchStr[0], &menuTouch ),
+#endif
     DEF_OPT_BIND( optBindStr[ 2], configKeyA ),
     DEF_OPT_BIND( optBindStr[ 3], configKeyB ),
     DEF_OPT_BIND( optBindStr[ 4], configKeyStart ),
@@ -222,6 +235,15 @@ static struct Option optsControls[] = {
     DEF_OPT_SCROLL( optBindStr[21], &configRumbleStrength, 0, 100, 1),
 #endif
 };
+
+#ifdef TOUCH_CONTROLS
+static struct Option optsTouch[] = {
+    DEF_OPT_TOGGLE( optTouchStr[1], &configAutohideTouch ),
+};
+
+struct SubMenu menuTouch = DEF_SUBMENU( optTouchStr[0], optsTouch );
+#endif
+
 #endif
 
 #ifndef TARGET_N64
diff --git a/src/game/behaviors/piranha_bubbles.inc.c b/src/game/behaviors/piranha_bubbles.inc.c
index d6037deb0..a86ffee42 100644
--- a/src/game/behaviors/piranha_bubbles.inc.c
+++ b/src/game/behaviors/piranha_bubbles.inc.c
@@ -37,8 +37,10 @@ void bhv_piranha_plant_bubble_loop(void) {
 
     cur_obj_set_pos_relative(parent, 0, 72.0f, 180.0f);
 
-#if defined(__clang__) // Hack: This fixes weird crash in clang (TARGET_ANDROID)
-    if (animFrame == -1) animFrame = 0;
+// This fixes a crash on clang ARM64, where the animFrame could go negative
+// due to an undefined behavior while calculating it's coss() value
+#if defined(__clang__)
+    if (animFrame < 0) animFrame = 0;
 #endif
 
     switch (o->oAction) {
diff --git a/src/game/camera.c b/src/game/camera.c
index 32d5d57c3..f8e5c6445 100644
--- a/src/game/camera.c
+++ b/src/game/camera.c
@@ -33,6 +33,10 @@
 #include "extras/bettercamera.h"
 #endif
 
+#ifdef TOUCH_CONTROLS
+#include "pc/controller/controller_touchscreen.h"
+#endif
+
 #define CBUTTON_MASK (U_CBUTTONS | D_CBUTTONS | L_CBUTTONS | R_CBUTTONS)
 
 /**
@@ -3422,6 +3426,9 @@ void update_camera(struct Camera *c) {
     update_lakitu(c);
 
 #ifdef BETTERCAMERA
+#ifdef TOUCH_CONTROLS
+    gTouchAnalogCamera = FALSE;
+#endif
     }
     puppycam_default_config(); // load bettercam settings from config vars
 
diff --git a/src/game/mario_step.c b/src/game/mario_step.c
index 2c3f06263..241878f93 100644
--- a/src/game/mario_step.c
+++ b/src/game/mario_step.c
@@ -777,10 +777,10 @@ s32 perform_air_quarter_step(struct MarioState *m, Vec3f intendedPos, u32 stepAr
     // misalignment, you can activate these conditions in unexpected situations
     // Check if Mario can grab a wall.
 #if BETTER_RESOLVE_WALL_COLLISION
-    if (m->vel[1] <= 0.0f && (stepArg & AIR_STEP_CHECK_LEDGE_GRAB) && upperWall.numWalls == 0 && lowerWall.numWalls > 0) {
+    if (m->vel[1] <= 0.0f && (stepArg & AIR_STEP_CHECK_LEDGE_GRAB) && upperWall.numWalls == 0 && lowerWall.numWalls != 0) {
         // Check if any walls are grabbable.
         grabbedWall = check_ledge_grab(m, &lowerWall, intendedPos, nextPos, ledgePos, &ledgeFloor);
-        if (grabbedWall != NULL && ledgeFloor != NULL && ledgePos != NULL) {
+        if (grabbedWall != NULL && ledgeFloor != NULL) {
             vec3f_copy(m->pos, ledgePos);
             m->floor        = ledgeFloor;
             m->floorHeight  = ledgePos[1];
diff --git a/src/pc/configfile.c b/src/pc/configfile.c
index a221c193e..7a49b9249 100644
--- a/src/pc/configfile.c
+++ b/src/pc/configfile.c
@@ -89,6 +89,10 @@ unsigned int configKeyStickRight[MAX_BINDS] = { 0x014D,   VK_INVALID, VK_INVALID
 unsigned int configStickDeadzone = 16; // 16*DEADZONE_STEP=4960 (the original default deadzone)
 unsigned int configRumbleStrength = 50;
 
+#ifdef TOUCH_CONTROLS
+bool configAutohideTouch = false;
+#endif
+
 #ifdef EXTERNAL_DATA
 bool configPrecacheRes = true;
 #endif
@@ -203,6 +207,9 @@ static const struct ConfigOption options[] = {
     {.name = "bettercam_inputtype",  .type = CONFIG_TYPE_UINT, .uintValue = &configPuppyCam.input},
     {.name = "bettercam_debug",      .type = CONFIG_TYPE_BOOL, .boolValue = &configPuppyCam.debug},
 #endif
+#ifdef TOUCH_CONTROLS
+    {.name = "touch_autohide",       .type = CONFIG_TYPE_BOOL, .boolValue = &configAutohideTouch},
+#endif
 };
 
 // Reads an entire line from a file (excluding the newline character) and returns an allocated string
diff --git a/src/pc/configfile.h b/src/pc/configfile.h
index 0bd98e75e..2aab0ef76 100644
--- a/src/pc/configfile.h
+++ b/src/pc/configfile.h
@@ -54,8 +54,13 @@ extern unsigned int configKeyStickLeft[];
 extern unsigned int configKeyStickRight[];
 extern unsigned int configStickDeadzone;
 extern unsigned int configRumbleStrength;
+
+#ifdef TOUCH_CONTROLS
+extern bool configAutohideTouch;
+#endif
+
 #ifdef EXTERNAL_DATA
-extern bool         configPrecacheRes;
+extern bool configPrecacheRes;
 #endif
 
 #if MORE_VANILLA_CAM_STUFF
diff --git a/src/pc/controller/controller_keyboard.c b/src/pc/controller/controller_keyboard.c
index 0f9a04ab3..55404f5e6 100644
--- a/src/pc/controller/controller_keyboard.c
+++ b/src/pc/controller/controller_keyboard.c
@@ -11,6 +11,9 @@
 
 #include "../configfile.h"
 #include "controller_keyboard.h"
+#ifdef TOUCH_CONTROLS
+#include "controller_touchscreen.h"
+#endif
 
 static int keyboard_buttons_down;
 
@@ -93,6 +96,9 @@ static void keyboard_init(void) {
 
 static void keyboard_read(OSContPad *pad) {
     pad->button |= keyboard_buttons_down;
+#ifdef TOUCH_CONTROLS
+    if (keyboard_buttons_down) gTouchControlsInUse = FALSE;
+#endif
     const u32 xstick = keyboard_buttons_down & STICK_XMASK;
     const u32 ystick = keyboard_buttons_down & STICK_YMASK;
     if (xstick == STICK_LEFT)
diff --git a/src/pc/controller/controller_sdl2.c b/src/pc/controller/controller_sdl2.c
index 5e8b158b5..256ad30fa 100644
--- a/src/pc/controller/controller_sdl2.c
+++ b/src/pc/controller/controller_sdl2.c
@@ -17,6 +17,9 @@
 #include "../configfile.h"
 #include "../platform.h"
 #include "../fs/fs.h"
+#ifdef TOUCH_CONTROLS
+#include "controller_touchscreen.h"
+#endif
 
 #include "game/level_update.h"
 
@@ -246,6 +249,9 @@ static void controller_sdl_read(OSContPad *pad) {
 
     for (u32 i = 0; i < SDL_CONTROLLER_BUTTON_MAX; ++i) {
         const bool new = SDL_GameControllerGetButton(sdl_cntrl, i);
+#ifdef TOUCH_CONTROLS
+        if (new) gTouchControlsInUse = FALSE;
+#endif
         update_button(i, new);
     }
 
diff --git a/src/pc/controller/controller_touchscreen.c b/src/pc/controller/controller_touchscreen.c
index 02b9cc627..42d416656 100644
--- a/src/pc/controller/controller_touchscreen.c
+++ b/src/pc/controller/controller_touchscreen.c
@@ -12,6 +12,7 @@
 #include "game/segment2.h"
 #include "gfx_dimensions.h"
 #include "pc/gfx/gfx_pc.h"
+#include "../configfile.h"
 
 #include "controller_api.h"
 #include "controller_touchscreen.h"
@@ -41,7 +42,7 @@ struct ControlElement {
     struct Position (*GetPos)();
     u8 touchID; //0 = not being touched, 1-255 = Finger being used
     //Joystick
-    int joyX, joyY;
+    int joyX, joyY, isJoyAnalog;
     //Button
     int buttonID;
     char character;
@@ -56,13 +57,20 @@ static int ControlElementsLength = sizeof(ControlElementsDefault)/sizeof(struct
 #define TRIGGER_DETECT(size) (((pos.x + size / 2 > CORRECT_TOUCH_X(event->x)) && (pos.x - size / 2 < CORRECT_TOUCH_X(event->x))) &&\
                               ((pos.y + size / 2 > CORRECT_TOUCH_Y(event->y)) && (pos.y - size / 2 < CORRECT_TOUCH_Y(event->y))))
 
+#define C_BUTTONS_TOUCH_DETECT(x) (x == U_CBUTTONS || x == D_CBUTTONS || x == L_CBUTTONS || x == R_CBUTTONS) 
+
+int gTouchControlsInUse;
+int gTouchAnalogCamera = FALSE;
+
 void touch_down(struct TouchEvent* event) {
+    gTouchControlsInUse = TRUE;
     struct Position pos;
     for(int i = 0; i < ControlElementsLength; i++) {
         if (ControlElements[i].touchID == 0) {
             pos = ControlElements[i].GetPos();
             switch (ControlElements[i].type) {
                 case Joystick:
+                    if (ControlElements[i].isJoyAnalog && !gTouchAnalogCamera) break;
                     if (TRIGGER_DETECT(JOYSTICK_SIZE)) {
                         ControlElements[i].touchID = event->touchID;
                         ControlElements[i].joyX = CORRECT_TOUCH_X(event->x) - pos.x;
@@ -70,6 +78,7 @@ void touch_down(struct TouchEvent* event) {
                     }
                     break;
                 case Button:
+                    if (C_BUTTONS_TOUCH_DETECT(ControlElements[i].buttonID) && gTouchAnalogCamera) break;
                     if (TRIGGER_DETECT(120)) {
                         ControlElements[i].touchID = event->touchID;
                     }
@@ -87,6 +96,7 @@ void touch_motion(struct TouchEvent* event) {
             pos = ControlElements[i].GetPos();
                 switch (ControlElements[i].type) {
                     case Joystick:
+                        if (ControlElements[i].isJoyAnalog && !gTouchAnalogCamera) break;
                         ; //workaround
                         s32 x,y;
                         x = CORRECT_TOUCH_X(event->x) - pos.x;
@@ -104,6 +114,7 @@ void touch_motion(struct TouchEvent* event) {
                         ControlElements[i].joyY = y;
                         break;
                     case Button:
+                        if (C_BUTTONS_TOUCH_DETECT(ControlElements[i].buttonID) && gTouchAnalogCamera) break;
                         if (ControlElements[i].slideTouch && !TRIGGER_DETECT(120)) {
                             ControlElements[i].slideTouch = 0;
                             ControlElements[i].touchID = 0;
@@ -116,6 +127,7 @@ void touch_motion(struct TouchEvent* event) {
                 case Joystick:
                     break;
                 case Button:
+                    if (C_BUTTONS_TOUCH_DETECT(ControlElements[i].buttonID) && gTouchAnalogCamera) break;
                     if (TRIGGER_DETECT(120)) {
                         ControlElements[i].slideTouch = 1;
                         ControlElements[i].touchID = event->touchID;
@@ -130,6 +142,7 @@ static void handle_touch_up(int i) {//seperated for when the layout changes
     ControlElements[i].touchID = 0;
     switch (ControlElements[i].type) {
         case Joystick:
+            if (ControlElements[i].isJoyAnalog && !gTouchAnalogCamera) break;
             ControlElements[i].joyX = 0;
             ControlElements[i].joyY = 0;
             break;
@@ -182,6 +195,7 @@ static void DrawSprite(s32 x, s32 y, int scaling) {
 }
 
 void render_touch_controls(void) {
+    if (!gTouchControlsInUse && configAutohideTouch) return;
     Mtx *mtx;
 
     mtx = alloc_display_list(sizeof(*mtx));
@@ -200,11 +214,13 @@ void render_touch_controls(void) {
         select_button_texture(0);
         switch (ControlElements[i].type) {
             case Joystick:
+                if (ControlElements[i].isJoyAnalog && !gTouchAnalogCamera) break;
                 pos = ControlElements[i].GetPos();
                 DrawSprite(pos.x, pos.y, 3);
                 DrawSprite(pos.x + 4 + ControlElements[i].joyX, pos.y + 4 + ControlElements[i].joyY, 2);
                 break;
             case Button:
+                if (C_BUTTONS_TOUCH_DETECT(ControlElements[i].buttonID) && gTouchAnalogCamera) break;
                 if (ControlElements[i].touchID)
                     select_button_texture(1);
                 pos = ControlElements[i].GetPos();
@@ -226,11 +242,17 @@ static void touchscreen_read(OSContPad *pad) {
         switch (ControlElements[i].type) {
             case Joystick:
                 if (ControlElements[i].joyX || ControlElements[i].joyY) {
-                    pad->stick_x = (ControlElements[i].joyX + JOYSTICK_SIZE/2) * 255 / JOYSTICK_SIZE - 128;
-                    pad->stick_y = (-ControlElements[i].joyY + JOYSTICK_SIZE/2) * 255 / JOYSTICK_SIZE - 128; //inverted for some reason
+                    if (ControlElements[i].isJoyAnalog && gTouchAnalogCamera) {
+                        pad->ext_stick_x = (ControlElements[i].joyX + JOYSTICK_SIZE/2) * 255 / JOYSTICK_SIZE - 128;
+                        pad->ext_stick_y = (-ControlElements[i].joyY + JOYSTICK_SIZE/2) * 255 / JOYSTICK_SIZE - 128; //inverted for some reason
+                    } else {
+                        pad->stick_x = (ControlElements[i].joyX + JOYSTICK_SIZE/2) * 255 / JOYSTICK_SIZE - 128;
+                        pad->stick_y = (-ControlElements[i].joyY + JOYSTICK_SIZE/2) * 255 / JOYSTICK_SIZE - 128; //inverted for some reason
+                    }
                 }
                 break;
             case Button:
+                if (C_BUTTONS_TOUCH_DETECT(ControlElements[i].buttonID) && gTouchAnalogCamera) break;
                 if (ControlElements[i].touchID) {
                     pad->button |= ControlElements[i].buttonID;
                 }
diff --git a/src/pc/controller/controller_touchscreen.h b/src/pc/controller/controller_touchscreen.h
index 13f4724ce..d780fd442 100644
--- a/src/pc/controller/controller_touchscreen.h
+++ b/src/pc/controller/controller_touchscreen.h
@@ -13,5 +13,8 @@ void touch_up(struct TouchEvent* event);
 
 extern struct ControllerAPI controller_touchscreen;
 
+extern int gTouchControlsInUse;
+extern int gTouchAnalogCamera;
+
 #endif
 #endif
diff --git a/src/pc/controller/controller_touchscreen_layouts.inc b/src/pc/controller/controller_touchscreen_layouts.inc
index 4e219bece..f01848080 100644
--- a/src/pc/controller/controller_touchscreen_layouts.inc
+++ b/src/pc/controller/controller_touchscreen_layouts.inc
@@ -7,6 +7,11 @@ struct Position GetDefaultJoystickPos() {
     return ret;
 }
 
+struct Position GetDefaultJoystickAnalogPos() {
+    struct Position ret = { .x = GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(60) << 2, .y = 290 };
+    return ret;
+}
+
 struct Position GetDefaultStartPos() {
     struct Position ret = { .x = SCREEN_WIDTH_API / 2, .y = 900 };
     return ret;
@@ -58,7 +63,8 @@ struct Position GetDefaultRightPos() {
 }
 
 static struct ControlElement ControlElementsDefault[] = {
-{.type = Joystick, .GetPos = GetDefaultJoystickPos},
+{.type = Joystick, .GetPos = GetDefaultJoystickPos, .isJoyAnalog = FALSE},
+{.type = Joystick, .GetPos = GetDefaultJoystickAnalogPos, .isJoyAnalog = TRUE},
 {.type = Button, .GetPos = GetDefaultStartPos, .character = 's', .buttonID = START_BUTTON},
 {.type = Button, .GetPos = GetDefaultAPos, .character = 'a', .buttonID = A_BUTTON},
 {.type = Button, .GetPos = GetDefaultBPos, .character = 'b', .buttonID = B_BUTTON},
diff --git a/src/pc/pc_main.c b/src/pc/pc_main.c
index ad95e2c28..d9f5564ec 100644
--- a/src/pc/pc_main.c
+++ b/src/pc/pc_main.c
@@ -259,12 +259,13 @@ void main_func(void) {
     //Move old stuff to new path
     const char *basedir = SDL_AndroidGetExternalStoragePath();
     char gamedir[SYS_MAX_PATH];
+    struct stat st;
     #ifdef COMMAND_LINE_OPTIONS
     snprintf(gamedir, sizeof(gamedir), "%s/%s", basedir, gCLIOpts.GameDir[0] ? gCLIOpts.GameDir : FS_BASEDIR);
     #else
     snprintf(gamedir, sizeof(gamedir), "%s/%s", basedir, FS_BASEDIR);
     #endif
-    if (stat(gamedir, NULL) == -1) {
+    if (stat(gamedir, &st) == -1) {
         mkdir(gamedir, 0770);
     }
     move_to_new_dir("sound");
diff --git a/tools/assemble_sound.py b/tools/assemble_sound.py
index ea298e44f..310eec0c0 100644
--- a/tools/assemble_sound.py
+++ b/tools/assemble_sound.py
@@ -66,7 +66,7 @@ def validate(cond, msg, forstr=""):
 
 
 def strip_comments(string):
-    string = re.sub(re.compile("/\*.*?\*/", re.DOTALL), "", string)
+    string = re.sub(re.compile(r"/\*.*?\*/", re.DOTALL), "", string)
     return re.sub(re.compile("//.*?\n"), "", string)
 
 
diff --git a/tools/audiofile/audiofile.cpp b/tools/audiofile/audiofile.cpp
index bd0279f17..fc5b73846 100644
--- a/tools/audiofile/audiofile.cpp
+++ b/tools/audiofile/audiofile.cpp
@@ -3552,6 +3552,17 @@ struct IntTypes<kInt24> { typedef int32_t SignedType; typedef uint32_t UnsignedT
 template <>
 struct IntTypes<kInt32> { typedef int32_t SignedType; typedef uint32_t UnsignedType; };
 
+namespace compat
+{
+	template<typename Arg, typename R>
+	class unary_function
+	{
+	public:
+		using argument_type = Arg;
+		using result_type = R;
+	};
+}
+
 template <FormatCode Format>
 struct signConverter
 {
@@ -3562,17 +3573,13 @@ struct signConverter
 	static const int kMaxSignedValue = (((1 << (kScaleBits - 1)) - 1) << 1) + 1;
 	static const int kMinSignedValue = -kMaxSignedValue - 1;
 
-	struct signedToUnsigned
+	struct signedToUnsigned : public compat::unary_function<SignedType, UnsignedType>
  	{
-		typedef SignedType argument_type;
-		typedef UnsignedType result_type;
 		UnsignedType operator()(SignedType x) { return x - kMinSignedValue; }
 	};
 
-	struct unsignedToSigned
+	struct unsignedToSigned : public compat::unary_function<SignedType, UnsignedType>
  	{
-		typedef SignedType argument_type;
-		typedef UnsignedType result_type;
 		SignedType operator()(UnsignedType x) { return x + kMinSignedValue; }
 	};
 };
@@ -3764,10 +3771,8 @@ struct Compress4To3Module : public SimpleModule
 };
 
 template <typename Arg, typename Result>
-struct intToFloat
+struct intToFloat : public compat::unary_function<Arg, Result>
 {
-	typedef Arg argument_type;
-	typedef Result result_type;
 	Result operator()(Arg x) const { return x; }
 };
 
@@ -3832,18 +3837,14 @@ struct ConvertIntToFloat : public SimpleModule
 };
 
 template <typename Arg, typename Result, unsigned shift>
-struct lshift
+struct lshift : public compat::unary_function<Arg, Result>
 {
-	typedef Arg argument_type;
-	typedef Result result_type;
 	Result operator()(const Arg &x) const { return x << shift; }
 };
 
 template <typename Arg, typename Result, unsigned shift>
-struct rshift
+struct rshift : public compat::unary_function<Arg, Result>
 {
-	typedef Arg argument_type;
-	typedef Result result_type;
 	Result operator()(const Arg &x) const { return x >> shift; }
 };
 
@@ -3938,10 +3939,8 @@ struct ConvertInt : public SimpleModule
 };
 
 template <typename Arg, typename Result>
-struct floatToFloat
+struct floatToFloat : public compat::unary_function<Arg, Result>
 {
-	typedef Arg argument_type;
-	typedef Result result_type;
 	Result operator()(Arg x) const { return x; }
 };
 
@@ -8064,7 +8063,7 @@ static char s_tmpSampleBuf[2048];
 std::string AudioFormat::description() const
 {
 	std::string d;
-              
+
 	/* sampleRate, channelCount */
 	snprintf(s_tmpSampleBuf, sizeof(s_tmpSampleBuf), "{ %7.2f Hz %d ch ", sampleRate, channelCount);
 	d += s_tmpSampleBuf;

From a6e86d018668288ac96b3b20bb99c2252f443a7f Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Thu, 21 Nov 2024 19:14:37 -0500
Subject: [PATCH 02/15] Fix DirectX window config save position and size and
 fullscreen

Also disable mouse visibility for now

Not the best fix but dealing with this was tedious
---
 src/pc/gfx/gfx_dxgi.cpp | 103 +++++++++++++++++++++++++---------------
 1 file changed, 66 insertions(+), 37 deletions(-)

diff --git a/src/pc/gfx/gfx_dxgi.cpp b/src/pc/gfx/gfx_dxgi.cpp
index d58c50a23..3f8dbde7c 100644
--- a/src/pc/gfx/gfx_dxgi.cpp
+++ b/src/pc/gfx/gfx_dxgi.cpp
@@ -8,6 +8,7 @@
 #include <string>
 
 #include <windows.h>
+#include <windowsx.h> // GET_X_LPARAM(), GET_Y_LPARAM()
 #include <wrl/client.h>
 #include <dxgi1_3.h>
 #include <versionhelpers.h>
@@ -146,19 +147,28 @@ static void run_as_dpi_aware(Fun f) {
     }
 }
 
+static bool gfx_dxgi_is_window_maximized(void) {
+    WINDOWPLACEMENT window_placement;
+    window_placement.length = sizeof(WINDOWPLACEMENT);
+    GetWindowPlacement(dxgi.h_wnd, &window_placement);
+    return window_placement.showCmd == SW_SHOWMAXIMIZED;
+}
+
 static void toggle_borderless_window_full_screen(bool enable) {
     // Windows 7 + flip mode + waitable object can't go to exclusive fullscreen,
     // so do borderless instead. If DWM is enabled, this means we get one monitor
     // sync interval of latency extra. On Win 10 however (maybe Win 8 too), due to
     // "fullscreen optimizations" the latency is eliminated.
 
-    if (enable == dxgi.is_full_screen) {
+    /*if (enable == dxgi.is_full_screen) {
         return;
-    }
+    }*/
 
     if (!enable) {
-        RECT r = dxgi.last_window_rect;
+        dxgi.is_full_screen = false;  // Call this early so last_maximized_state works
+        configWindow.exiting_fullscreen = true; // To ensure no WM value actions are overwritten
 
+        RECT r = dxgi.last_window_rect;
         // Set in window mode with the last saved position and size
         SetWindowLongPtr(dxgi.h_wnd, GWL_STYLE, WS_VISIBLE | WS_OVERLAPPEDWINDOW);
 
@@ -169,23 +179,18 @@ static void toggle_borderless_window_full_screen(bool enable) {
             SetWindowPos(dxgi.h_wnd, NULL, r.left, r.top, r.right - r.left, r.bottom - r.top, SWP_FRAMECHANGED);
             ShowWindow(dxgi.h_wnd, SW_RESTORE);
         }
-
-        ShowCursor(TRUE);
-
-        dxgi.is_full_screen = false;
+        configWindow.exiting_fullscreen = false;
+        //ShowCursor(TRUE);
     } else {
+        dxgi.is_full_screen = true; // Call this early so it doesn't get called twice
+
         // Save if window is maximized or not
-        WINDOWPLACEMENT window_placement;
-        window_placement.length = sizeof(WINDOWPLACEMENT);
-        GetWindowPlacement(dxgi.h_wnd, &window_placement);
-        dxgi.last_maximized_state = window_placement.showCmd == SW_SHOWMAXIMIZED;
-
-        // Save window position and size if the window is not maximized
-        GetWindowRect(dxgi.h_wnd, &dxgi.last_window_rect);
-        configWindow.x = dxgi.last_window_rect.left;
-        configWindow.y = dxgi.last_window_rect.top;
-        configWindow.w = dxgi.last_window_rect.right - dxgi.last_window_rect.left;
-        configWindow.h = dxgi.last_window_rect.bottom - dxgi.last_window_rect.top;
+        dxgi.last_maximized_state = gfx_dxgi_is_window_maximized();
+
+        // Save last window position if the window is not maximized
+        if (!dxgi.last_maximized_state) {
+            GetWindowRect(dxgi.h_wnd, &dxgi.last_window_rect);
+        }
 
         // Get in which monitor the window is
         HMONITOR h_monitor = MonitorFromWindow(dxgi.h_wnd, MONITOR_DEFAULTTONEAREST);
@@ -200,23 +205,35 @@ static void toggle_borderless_window_full_screen(bool enable) {
         SetWindowLongPtr(dxgi.h_wnd, GWL_STYLE, WS_VISIBLE | WS_POPUP);
         SetWindowPos(dxgi.h_wnd, HWND_TOP, r.left, r.top, r.right - r.left, r.bottom - r.top, SWP_FRAMECHANGED);
 
-        ShowCursor(FALSE);
+        //ShowCursor(FALSE);
+    }
+}
 
-        dxgi.is_full_screen = true;
+// Only called on window init and reset defaults
+static void gfx_dxgi_set_screen_position(void) {
+    if (dxgi.is_full_screen) {
+        return;
     }
+
+    const int screen_width = GetSystemMetrics(SM_CXSCREEN);
+    const int screen_height = GetSystemMetrics(SM_CYSCREEN);
+    const int xpos = (configWindow.x == WAPI_WIN_CENTERPOS) ? (screen_width - configWindow.w) * 0.5 : configWindow.x;
+    const int ypos = (configWindow.y == WAPI_WIN_CENTERPOS) ? (screen_height - configWindow.h) * 0.5 : configWindow.y;
+    RECT wr = { xpos, ypos, xpos + (int)configWindow.w, ypos + (int)configWindow.h };
+    AdjustWindowRect(&wr, WS_OVERLAPPEDWINDOW, FALSE);
+    SetWindowPos(dxgi.h_wnd, NULL, wr.left, wr.top, wr.right - wr.left, wr.bottom - wr.top, SWP_NOACTIVATE | SWP_NOZORDER);
+
 }
 
-static void update_screen_settings(void) {
+static void gfx_dxgi_set_fullscreen(void) {
     if (configWindow.fullscreen != dxgi.is_full_screen)
-        toggle_borderless_window_full_screen(configWindow.fullscreen);
-    if (!dxgi.is_full_screen) {
-        const int screen_width = GetSystemMetrics(SM_CXSCREEN);
-        const int screen_height = GetSystemMetrics(SM_CYSCREEN);
-        const int xpos = (configWindow.x == WAPI_WIN_CENTERPOS) ? (screen_width - configWindow.w) * 0.5 : configWindow.x;
-        const int ypos = (configWindow.y == WAPI_WIN_CENTERPOS) ? (screen_height - configWindow.h) * 0.5 : configWindow.y;
-        RECT wr = { xpos, ypos, xpos + (int)configWindow.w, ypos + (int)configWindow.h };
-        AdjustWindowRect(&wr, WS_OVERLAPPEDWINDOW, FALSE);
-        SetWindowPos(dxgi.h_wnd, NULL, wr.left, wr.top, wr.right - wr.left, wr.bottom - wr.top, SWP_NOACTIVATE | SWP_NOZORDER);
+        configWindow.fullscreen == dxgi.is_full_screen;
+    if (configWindow.fullscreen == dxgi.is_full_screen)
+        return;
+    if (configWindow.fullscreen) {
+        toggle_borderless_window_full_screen(true);
+    } else {
+        toggle_borderless_window_full_screen(false);
     }
 }
 
@@ -228,7 +245,7 @@ static void gfx_dxgi_on_resize(void) {
         ThrowIfFailed(dxgi.swap_chain->GetDesc1(&desc1));
         dxgi.current_width = desc1.Width;
         dxgi.current_height = desc1.Height;
-        if (!dxgi.is_full_screen) {
+        if (!dxgi.is_full_screen && !gfx_dxgi_is_window_maximized() && !configWindow.exiting_fullscreen) {
             configWindow.w = dxgi.current_width;
             configWindow.h = dxgi.current_height;
         }
@@ -252,6 +269,11 @@ static LRESULT CALLBACK gfx_dxgi_wnd_proc(HWND h_wnd, UINT message, WPARAM w_par
     switch (message) {
         case WM_SIZE:
             gfx_dxgi_on_resize();
+        case WM_MOVE:
+            if (!dxgi.is_full_screen && !gfx_dxgi_is_window_maximized() && !configWindow.exiting_fullscreen) {
+                configWindow.x = GET_X_LPARAM(l_param);
+                configWindow.y = GET_Y_LPARAM(l_param);
+            }
             break;
         case WM_DESTROY:
             game_exit();
@@ -278,7 +300,8 @@ static LRESULT CALLBACK gfx_dxgi_wnd_proc(HWND h_wnd, UINT message, WPARAM w_par
             break;
         case WM_SYSKEYDOWN:
             if ((w_param == VK_RETURN) && ((l_param & 1 << 30) == 0)) {
-                toggle_borderless_window_full_screen(!dxgi.is_full_screen);
+                configWindow.fullscreen = !configWindow.fullscreen;
+                configWindow.settings_changed = true;
                 break;
             } else {
                 return DefWindowProcW(h_wnd, message, w_param, l_param);
@@ -289,18 +312,22 @@ static LRESULT CALLBACK gfx_dxgi_wnd_proc(HWND h_wnd, UINT message, WPARAM w_par
 
     if (configWindow.reset) {
         dxgi.last_maximized_state = false;
-        configWindow.reset = false;
+        configWindow.fullscreen = false;
+        configWindow.settings_changed = true;
+        if (gfx_dxgi_is_window_maximized()) {
+            ShowWindow(dxgi.h_wnd, SW_RESTORE);
+        }
         configWindow.x = WAPI_WIN_CENTERPOS;
         configWindow.y = WAPI_WIN_CENTERPOS;
         configWindow.w = DESIRED_SCREEN_WIDTH;
         configWindow.h = DESIRED_SCREEN_HEIGHT;
-        configWindow.fullscreen = false;
-        configWindow.settings_changed = true;
+        gfx_dxgi_set_screen_position();
+        configWindow.reset = false;
     }
 
     if (configWindow.settings_changed) {
+        gfx_dxgi_set_fullscreen();
         configWindow.settings_changed = false;
-        update_screen_settings();
     }
 
     return 0;
@@ -351,10 +378,12 @@ static void gfx_dxgi_init(const char *window_title) {
 
     load_dxgi_library();
 
+    gfx_dxgi_set_screen_position();
+
     ShowWindow(dxgi.h_wnd, SW_SHOW);
     UpdateWindow(dxgi.h_wnd);
 
-    update_screen_settings();
+    gfx_dxgi_set_fullscreen();
 }
 
 static void gfx_dxgi_set_keyboard_callbacks(bool (*on_key_down)(int scancode), bool (*on_key_up)(int scancode), void (*on_all_keys_up)(void)) {

From a3ff29bbe216e9e8b46fc82afb8090c14f7ec5a2 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Thu, 21 Nov 2024 22:55:19 -0500
Subject: [PATCH 03/15] Some DXGI fixes (from HM64)

Fixed DXGI events, now the game "pauses" when dragging or moving like SDL2

Fixed config reset setting width and height as their x and y pos sometimes

Fixed DirectX memory leak and use flip discard on Windows 10
---
 src/pc/gfx/gfx_dxgi.cpp | 59 ++++++++++++++++++++++++++---------------
 1 file changed, 37 insertions(+), 22 deletions(-)

diff --git a/src/pc/gfx/gfx_dxgi.cpp b/src/pc/gfx/gfx_dxgi.cpp
index 3f8dbde7c..f1890a69f 100644
--- a/src/pc/gfx/gfx_dxgi.cpp
+++ b/src/pc/gfx/gfx_dxgi.cpp
@@ -11,6 +11,7 @@
 #include <windowsx.h> // GET_X_LPARAM(), GET_Y_LPARAM()
 #include <wrl/client.h>
 #include <dxgi1_3.h>
+#include <dxgi1_4.h>
 #include <versionhelpers.h>
 
 #include <shellscalingapi.h>
@@ -59,10 +60,11 @@ using namespace Microsoft::WRL; // For ComPtr
 
 static struct {
     HWND h_wnd;
-    bool showing_error;
     uint32_t current_width, current_height;
     std::string window_title;
 
+    bool is_running = true;
+
     HMODULE dxgi_module;
     HRESULT (__stdcall *CreateDXGIFactory1)(REFIID riid, void **factory);
     HRESULT (__stdcall *CreateDXGIFactory2)(UINT flags, REFIID iid, void **factory);
@@ -72,6 +74,7 @@ static struct {
     RECT last_window_rect;
     bool is_full_screen, last_maximized_state;
 
+    bool dxgi1_4;
     ComPtr<IDXGIFactory2> factory;
     ComPtr<IDXGISwapChain1> swap_chain;
     HANDLE waitable_object;
@@ -275,16 +278,12 @@ static LRESULT CALLBACK gfx_dxgi_wnd_proc(HWND h_wnd, UINT message, WPARAM w_par
                 configWindow.y = GET_Y_LPARAM(l_param);
             }
             break;
-        case WM_DESTROY:
-            game_exit();
-            break;
-        case WM_PAINT:
-            if (dxgi.showing_error) {
-                return DefWindowProcW(h_wnd, message, w_param, l_param);
-            } else {
-                if (dxgi.run_one_game_iter != nullptr) {
-                    dxgi.run_one_game_iter();
-                }
+        case WM_CLOSE:
+            dxgi.is_running = false;
+        case WM_ENDSESSION:
+            // This hopefully gives the game a chance to shut down, before windows kills it.
+            if (w_param == TRUE) {
+                dxgi.is_running = false;
             }
             break;
         case WM_ACTIVATEAPP:
@@ -313,6 +312,7 @@ static LRESULT CALLBACK gfx_dxgi_wnd_proc(HWND h_wnd, UINT message, WPARAM w_par
     if (configWindow.reset) {
         dxgi.last_maximized_state = false;
         configWindow.fullscreen = false;
+        configWindow.exiting_fullscreen = true;
         configWindow.settings_changed = true;
         if (gfx_dxgi_is_window_maximized()) {
             ShowWindow(dxgi.h_wnd, SW_RESTORE);
@@ -395,10 +395,8 @@ static void gfx_dxgi_set_keyboard_callbacks(bool (*on_key_down)(int scancode), b
 static void gfx_dxgi_main_loop(void (*run_one_game_iter)(void)) {
     dxgi.run_one_game_iter = run_one_game_iter;
 
-    MSG msg;
-    while (GetMessage(&msg, nullptr, 0, 0)) {
-        TranslateMessage(&msg);
-        DispatchMessage(&msg);
+    while (dxgi.is_running) {
+        dxgi.run_one_game_iter();
     }
 }
 
@@ -408,11 +406,19 @@ static void gfx_dxgi_get_dimensions(uint32_t *width, uint32_t *height) {
 }
 
 static void gfx_dxgi_handle_events(void) {
-    /*MSG msg;
+    MSG msg;
     while (PeekMessageW(&msg, nullptr, 0, 0, PM_REMOVE)) {
+        if (msg.message == WM_QUIT) {
+            dxgi.is_running = false;
+            break;
+        }
         TranslateMessage(&msg);
         DispatchMessage(&msg);
-    }*/
+    }
+
+    if (dxgi.is_running == false) {
+        game_exit();
+    }
 }
 
 static uint64_t qpc_to_us(uint64_t qpc) {
@@ -540,10 +546,10 @@ static bool gfx_dxgi_start_frame(void) {
 static void gfx_dxgi_swap_buffers_begin(void) {
     //dxgi.length_in_vsync_frames = 1;
     ThrowIfFailed(dxgi.swap_chain->Present(dxgi.length_in_vsync_frames, 0));
-    UINT this_present_id;
+    /*UINT this_present_id;
     if (dxgi.swap_chain->GetLastPresentCount(&this_present_id) == S_OK) {
         dxgi.pending_frame_stats.insert(std::make_pair(this_present_id, dxgi.length_in_vsync_frames));
-    }
+    }*/
     dxgi.dropped_frame = false;
 }
 
@@ -564,7 +570,7 @@ static void gfx_dxgi_swap_buffers_end(void) {
 
     QueryPerformanceCounter(&t2);
 
-    dxgi.sync_interval_means_frames_to_wait = dxgi.pending_frame_stats.rbegin()->first == stats.PresentCount;
+    //dxgi.sync_interval_means_frames_to_wait = dxgi.pending_frame_stats.rbegin()->first == stats.PresentCount;
 
     //printf("done %llu gpu:%d wait:%d freed:%llu frame:%u %u monitor:%u t:%llu\n", (unsigned long long)(t0.QuadPart - dxgi.qpc_init), (int)(t1.QuadPart - t0.QuadPart), (int)(t2.QuadPart - t0.QuadPart), (unsigned long long)(t2.QuadPart - dxgi.qpc_init), dxgi.pending_frame_stats.rbegin()->first, stats.PresentCount, stats.SyncRefreshCount, (unsigned long long)(stats.SyncQPCTime.QuadPart - dxgi.qpc_init));
 }
@@ -582,6 +588,13 @@ void gfx_dxgi_create_factory_and_device(bool debug, int d3d_version, bool (*crea
         ThrowIfFailed(dxgi.CreateDXGIFactory1(__uuidof(IDXGIFactory2), &dxgi.factory));
     }
 
+    {
+        ComPtr<IDXGIFactory4> factory4;
+        if (dxgi.factory->QueryInterface(__uuidof(IDXGIFactory4), &factory4) == S_OK) {
+            dxgi.dxgi1_4 = true;
+        }
+    }
+
     ComPtr<IDXGIAdapter1> adapter;
     for (UINT i = 0; dxgi.factory->EnumAdapters1(i, &adapter) != DXGI_ERROR_NOT_FOUND; i++) {
         DXGI_ADAPTER_DESC1 desc;
@@ -612,7 +625,9 @@ ComPtr<IDXGISwapChain1> gfx_dxgi_create_swap_chain(IUnknown *device) {
     swap_chain_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
     swap_chain_desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
     swap_chain_desc.Scaling = win8 ? DXGI_SCALING_NONE : DXGI_SCALING_STRETCH;
-    swap_chain_desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL; // Apparently this was backported to Win 7 Platform Update
+    swap_chain_desc.SwapEffect = dxgi.dxgi1_4 ?
+        DXGI_SWAP_EFFECT_FLIP_DISCARD : // Introduced in DXGI 1.4 and Windows 10
+        DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL; // Apparently flip sequential was also backported to Win 7 Platform Update
     swap_chain_desc.Flags = dxgi_13 ? DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT : 0;
     swap_chain_desc.SampleDesc.Count = 1;
 
@@ -647,6 +662,7 @@ HWND gfx_dxgi_get_h_wnd(void) {
 }
 
 void gfx_dxgi_shutdown(void) {
+    //dxgi.is_running = false;
 }
 
 void ThrowIfFailed(HRESULT res) {
@@ -660,7 +676,6 @@ void ThrowIfFailed(HRESULT res, HWND h_wnd, const char *message) {
     if (FAILED(res)) {
         char full_message[256];
         sprintf(full_message, "%s\n\nHRESULT: 0x%08X", message, res);
-        dxgi.showing_error = true;
         MessageBox(h_wnd, full_message, "Error", MB_OK | MB_ICONERROR);
         throw res;
     }

From 5717a8c092d996b251d2e1842d09d1b58cff1dc7 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Thu, 21 Nov 2024 23:19:32 -0500
Subject: [PATCH 04/15] Better mouse handling plus DXGI support (from
 sm64coopdx)

Set DXGI mouse visibility (from HM64)

Proper mouse relative mode and buttons in DXGI (from sm64coopdx)

Ensure mouse doesn't escape window and simplify visible state
---
 README.md                            |   2 +-
 defines.mk                           |   8 +-
 src/extras/bettercamera.c            |  14 +-
 src/game/mario_actions_automatic.c   |   8 +-
 src/goddard/renderer.c               |  35 ++---
 src/menu/file_select.c               |  42 ++----
 src/pc/controller/controller_mouse.c | 200 +++++++++++++++++++++++++++
 src/pc/controller/controller_mouse.h |  32 ++++-
 src/pc/controller/controller_sdl1.c  |  54 +++-----
 src/pc/controller/controller_sdl2.c  |  60 ++++----
 src/pc/gfx/gfx_dxgi.cpp              |  33 ++++-
 src/pc/gfx/gfx_dxgi.h                |   3 +-
 12 files changed, 345 insertions(+), 146 deletions(-)
 create mode 100644 src/pc/controller/controller_mouse.c

diff --git a/README.md b/README.md
index 809f6c55f..99a1e9011 100644
--- a/README.md
+++ b/README.md
@@ -6,7 +6,7 @@ Fork of [sm64pc/sm64ex](https://github.com/sm64pc/sm64ex) with additional featur
  * Based of the latest refresh (since sm64ex is stuck on 12)
  * Puppycam 2 (sm64ex still has Puppycam 1)
  * Quality of life fixes and features (QOL_FIXES=1 and QOL_FEATURES=1 respectively)
- * Mouse support for desktop targets (MOUSE_ACTIONS=1) (SDL1/SDL2 only, DirectX Mouse not implemented yet)
+ * Mouse support for desktop targets (MOUSE_ACTIONS=1)
  * Simple debug options menu (EXT_DEBUG_MENU=1)
  * Kaze's more objects patch (PORT_MOP_OBJS=1)
  
diff --git a/defines.mk b/defines.mk
index 762961a13..8a1b3ac53 100644
--- a/defines.mk
+++ b/defines.mk
@@ -24,6 +24,8 @@ PORT_MOP_OBJS ?= 0
 VANILLA_CHECKS ?= 1
 # Enable extended bounds
 EXTENDED_BOUNDS ?= 0
+# Enable Mouse support
+MOUSE_ACTIONS ?= 1
 # Accept RM2C level folder output
 RM2C ?= 0
 
@@ -99,8 +101,8 @@ endif
 # Use PC-only exclusive defines
 ifeq ($(TARGET_PORT_CONSOLE),0)
 
-  # Check for Mouse Option (no DirectX yet)
-  ifneq ($(WINDOW_API),DXGI)
+  # Check for Mouse Option
+  ifeq ($(MOUSE_ACTIONS),1)
     CUSTOM_C_DEFINES += -DMOUSE_ACTIONS
   endif
 
@@ -108,7 +110,7 @@ ifeq ($(TARGET_PORT_CONSOLE),0)
   ifeq ($(DISCORDRPC),1)
     CUSTOM_C_DEFINES += -DDISCORDRPC
   endif
-  
+
   # Check for Command Line Options
   ifeq ($(COMMAND_LINE_OPTIONS),1)
     CUSTOM_C_DEFINES += -DCOMMAND_LINE_OPTIONS
diff --git a/src/extras/bettercamera.c b/src/extras/bettercamera.c
index 5209a2e8d..ee95d68d9 100644
--- a/src/extras/bettercamera.c
+++ b/src/extras/bettercamera.c
@@ -762,16 +762,16 @@ static void puppycam_input_mouse(void) {
     f32 ivY = ((gPuppyCam.options.invertY * 2) - 1) * (gPuppyCam.options.sensitivityY / PUPPYCAM_SENSITIVITY);
 
     if (configMouse && gPuppyCam.options.mouse) {
-        gMouseHasCenterControl = TRUE;
+        mouse_has_center_control = TRUE;
 
         if (gPuppyCam.flags & PUPPYCAM_BEHAVIOUR_FREE) {
             if (gPlayer1Controller->buttonDown & A_BUTTON) {
-                gPuppyCam.yawTarget -= ivX * gMouseXPos * (gPuppyCam.options.mouseSpeed * 1.5);
-                gPuppyCam.pitchTarget += ivY * gMouseYPos * (gPuppyCam.options.mouseSpeed * 1.5);
+                gPuppyCam.yawTarget -= ivX * mouse_x * (gPuppyCam.options.mouseSpeed * 1.5);
+                gPuppyCam.pitchTarget += ivY * mouse_y * (gPuppyCam.options.mouseSpeed * 1.5);
             }
         } else {
-            gPuppyCam.yawTarget -= ivX * gMouseXPos * gPuppyCam.options.mouseSpeed;
-            gPuppyCam.pitchTarget += ivY * gMouseYPos * gPuppyCam.options.mouseSpeed;
+            gPuppyCam.yawTarget -= ivX * mouse_x * gPuppyCam.options.mouseSpeed;
+            gPuppyCam.pitchTarget += ivY * mouse_y * gPuppyCam.options.mouseSpeed;
             // We allow free movement even on classic but after 15 frames of no mouse movement camera gets snapped.
             if (gPuppyCam.options.inputType == PUPPYCAM_INPUT_CLASSIC_STYLE && gPuppyCam.framesSinceMouse == 15) {
                 if (!(gPuppyCam.mode3Flags & PUPPYCAM_MODE3_ZOOMED_IN)) {
@@ -784,7 +784,7 @@ static void puppycam_input_mouse(void) {
         }
 
         // Increase timer when mouse is on idle, resets when mouse gets moved on any direction.
-        if (gMouseXPos + gMouseYPos != 0) {
+        if (mouse_x + mouse_y != 0) {
             gPuppyCam.framesSinceMouse = 0;
         } else {
             if (gPuppyCam.framesSinceMouse <= 20) {
@@ -792,7 +792,7 @@ static void puppycam_input_mouse(void) {
             }
         }
     } else {
-        gMouseHasCenterControl = FALSE;
+        mouse_has_center_control = FALSE;
         gPuppyCam.framesSinceMouse = 20;
     }
 }
diff --git a/src/game/mario_actions_automatic.c b/src/game/mario_actions_automatic.c
index 64eee5911..cb2d0b733 100644
--- a/src/game/mario_actions_automatic.c
+++ b/src/game/mario_actions_automatic.c
@@ -819,10 +819,10 @@ s32 act_in_cannon(struct MarioState *m) {
             marioObj->oMarioCannonInputYaw -= (s16)(m->controller->stickX * 10.0f);
 #ifdef MOUSE_ACTIONS
             if (configMouse) {
-                gMouseHasCenterControl = TRUE;
+                mouse_has_center_control = TRUE;
 
-                m->faceAngle[0] -= (s16)(gMouseYPos * 10.0f);
-                marioObj->oMarioCannonInputYaw -= (s16)(gMouseXPos * 10.0f);
+                m->faceAngle[0] -= (s16)(mouse_y * 10.0f);
+                marioObj->oMarioCannonInputYaw -= (s16)(mouse_x * 10.0f);
             }
 #endif
 
@@ -856,7 +856,7 @@ s32 act_in_cannon(struct MarioState *m) {
                 m->marioObj->header.gfx.node.flags |= GRAPH_RENDER_ACTIVE;
 
 #ifdef MOUSE_ACTIONS
-                gMouseHasCenterControl = FALSE;
+                mouse_has_center_control = FALSE;
 #endif
 
                 set_mario_action(m, ACT_SHOT_FROM_CANNON, 0);
diff --git a/src/goddard/renderer.c b/src/goddard/renderer.c
index a28cc180f..040304d84 100644
--- a/src/goddard/renderer.c
+++ b/src/goddard/renderer.c
@@ -2532,40 +2532,32 @@ void parse_p1_controller(void) {
         sDebugViews[sCurrDebugViewIndex - 1]->flags |= VIEW_UPDATE;
     }
 
+#ifdef MOUSE_ACTIONS 
+    controller_mouse_read_window();
+#endif
+
     // deadzone checks
     if (ABS(gdctrl->stickX) >= 6) {
         gdctrl->csrX += gdctrl->stickX * 0.1;
 #ifdef MOUSE_ACTIONS
-        gMouseHasFreeControl = FALSE;
+        mouse_has_current_control = FALSE;
 #endif
     }
 
     if (ABS(gdctrl->stickY) >= 6) {
         gdctrl->csrY -= gdctrl->stickY * 0.1;
 #ifdef MOUSE_ACTIONS 
-        gMouseHasFreeControl = FALSE;
+        mouse_has_current_control = FALSE;
 #endif
     }
 
 #ifdef MOUSE_ACTIONS
-    if (!(sHandView->flags & VIEW_UPDATE))
-        gMouseHasFreeControl = FALSE;
-
-    if ((gMouseXPos - gOldMouseXPos != 0 || gMouseYPos - gOldMouseYPos != 0) && (sHandView->flags & VIEW_UPDATE)) {
-        gMouseHasFreeControl = TRUE;
-    }
-
-    float screenScale = (float) gfx_current_dimensions.height / (float)SCREEN_HEIGHT;
-    if (configMouse && gMouseHasFreeControl) {
-        gdctrl->csrX = (gMouseXPos - (gfx_current_dimensions.width - (screenScale * (float)SCREEN_WIDTH))/ 2)/ screenScale;
-        gdctrl->csrY = gMouseYPos / screenScale;
-    }
-
-    gOldMouseXPos = gMouseXPos;
-    gOldMouseYPos = gMouseYPos;
-
-if (!gMouseHasFreeControl) {
+    float screenScale = (float) gfx_current_dimensions.height / SCREEN_HEIGHT;
+    f32 mousePosX = (f32) ((mouse_window_x - (gfx_current_dimensions.width - (screenScale * (float)SCREEN_WIDTH))/ 2)/ screenScale);
+    f32 mousePosY = (f32) (mouse_window_y / screenScale);
+if (!controller_mouse_set_position(&gdctrl->csrX, &gdctrl->csrY, mousePosX, mousePosY, (sHandView->flags & VIEW_UPDATE), TRUE))
 #endif
+    {
     // clamp cursor position within screen view bounds
     if (gdctrl->csrX < sScreenView->parent->upperLeft.x + GFX_DIMENSIONS_FROM_LEFT_EDGE(16.0f)) {
         gdctrl->csrX = sScreenView->parent->upperLeft.x + GFX_DIMENSIONS_FROM_LEFT_EDGE(16.0f);
@@ -2586,10 +2578,7 @@ if (!gMouseHasFreeControl) {
     for (i = 0; i < sizeof(OSContPad); i++) {
         ((u8 *) prevInputs)[i] = ((u8 *) currInputs)[i];
     }
-#ifdef MOUSE_ACTIONS
-    
-}
-#endif
+    }
 }
 
 void stub_renderer_4(f32 arg0) {
diff --git a/src/menu/file_select.c b/src/menu/file_select.c
index d8310b34d..5f672e1a1 100644
--- a/src/menu/file_select.c
+++ b/src/menu/file_select.c
@@ -1709,23 +1709,25 @@ void handle_controller_cursor_input(void) {
     s16 rawStickX = gPlayer1Controller->rawStickX;
     s16 rawStickY = gPlayer1Controller->rawStickY;
 
+#ifdef MOUSE_ACTIONS 
+    controller_mouse_read_window();
+#endif
+
     // Handle deadzone
     if (rawStickY > -2 && rawStickY < 2) {
         rawStickY = 0;
     }
     #ifdef MOUSE_ACTIONS 
-    else
-    {
-        gMouseHasFreeControl = FALSE;
+    else {
+        mouse_has_current_control = FALSE;
     }
     #endif
     if (rawStickX > -2 && rawStickX < 2) {
         rawStickX = 0;
     }
     #ifdef MOUSE_ACTIONS 
-    else
-    {
-        gMouseHasFreeControl = FALSE;
+    else {
+        mouse_has_current_control = FALSE;
     }
     #endif
 
@@ -1734,26 +1736,12 @@ void handle_controller_cursor_input(void) {
     sCursorPos[1] += rawStickY / 8;
 
 #ifdef MOUSE_ACTIONS
-    if (sSelectedFileNum != 0)
-        gMouseHasFreeControl = FALSE;
-        
-    if ((gMouseXPos - gOldMouseXPos != 0 || gMouseYPos - gOldMouseYPos != 0) && sSelectedFileNum == 0)  {
-        gMouseHasFreeControl = TRUE;
-    }
-
-    static float screenScale;
-    screenScale = (float) gfx_current_dimensions.height / SCREEN_HEIGHT;
-    if (gMouseHasFreeControl && configMouse) {
-        sCursorPos[0] = ((gMouseXPos - (gfx_current_dimensions.width - (screenScale * 320)) / 2) / screenScale) - 160.0f;
-        sCursorPos[1] = (gMouseYPos / screenScale - 120.0f) * -1;
-    }
-
-    gOldMouseXPos = gMouseXPos;
-    gOldMouseYPos = gMouseYPos;
-
-if (!gMouseHasFreeControl) {
+    float screenScale = (float) gfx_current_dimensions.height / SCREEN_HEIGHT;
+    f32 mousePosX = (((mouse_window_x - (gfx_current_dimensions.width - (screenScale * 320)) / 2) / screenScale) - 160.0f);
+    f32 mousePosY = ((mouse_window_y / screenScale - 120.0f) * -1);
+if (!controller_mouse_set_position(&sCursorPos[0], &sCursorPos[1], mousePosX, mousePosY, sSelectedFileNum == 0, FALSE))
 #endif
-    
+    {
     // Stop cursor from going offscreen
     if (sCursorPos[0] > GFX_DIMENSIONS_FROM_RIGHT_EDGE(188.0f)) {
         sCursorPos[0] = GFX_DIMENSIONS_FROM_RIGHT_EDGE(188.0f);
@@ -1768,9 +1756,7 @@ if (!gMouseHasFreeControl) {
     if (sCursorPos[1] < -90.0f) {
         sCursorPos[1] = -90.0f;
     }
-#ifdef MOUSE_ACTIONS
-}
-#endif
+    }
 
     if (sCursorClickingTimer == 0) {
         handle_cursor_button_input();
diff --git a/src/pc/controller/controller_mouse.c b/src/pc/controller/controller_mouse.c
new file mode 100644
index 000000000..8b9401317
--- /dev/null
+++ b/src/pc/controller/controller_mouse.c
@@ -0,0 +1,200 @@
+#include "controller_mouse.h"
+#include "../configfile.h"
+
+#ifdef WAPI_DXGI
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+extern HWND gfx_dxgi_get_h_wnd(void);
+extern void gfx_dxgi_set_cursor_visibility(bool visible);
+#elif defined(CAPI_SDL1)
+#include <SDL/SDL.h>
+#elif defined(CAPI_SDL2)
+#include <SDL2/SDL.h>
+#endif
+
+int mouse_prev_window_x;
+int mouse_prev_window_y;
+
+int mouse_has_center_control;
+int mouse_has_current_control;
+
+bool mouse_init_ok;
+
+u32 mouse_buttons;
+s32 mouse_x;
+s32 mouse_y;
+
+u32 mouse_window_buttons;
+s32 mouse_window_x;
+s32 mouse_window_y;
+
+bool mouse_relative_enabled;
+
+#ifdef WAPI_DXGI
+u32 mouse_relative_buttons_held_on_focus;
+u32 mouse_window_buttons_held_on_focus;
+bool mouse_dxgi_prev_focus;
+
+static u32 controller_mouse_dxgi_button_state(u32* mouse_held, bool has_focus) {
+    u32 mouse =
+        ((GetKeyState(VK_LBUTTON) < 0) ? (1 << 0) : 0) |
+        ((GetKeyState(VK_MBUTTON) < 0) ? (1 << 1) : 0) |
+        ((GetKeyState(VK_RBUTTON) < 0) ? (1 << 2) : 0);
+
+    bool prev_focus = mouse_dxgi_prev_focus;
+    mouse_dxgi_prev_focus = has_focus;
+
+    // Ignore mouse clicks when game window doesn't have focus.
+    if (!has_focus) { return 0; }
+    if (mouse_held == NULL) { return mouse; }
+
+    // Window just received input focus, ignore any held down mouse buttons.
+    if (!prev_focus && has_focus) {
+        *mouse_held = mouse;
+        return 0;
+    }
+
+    // Wait for a mouse button held down (e.g. while clicking on the window)
+    // to be released and pressed again.
+    *mouse_held = (*mouse_held) & mouse;
+    return ~(*mouse_held) & mouse;
+}
+#endif // WAPI_DXGI
+
+static void controller_mouse_is_visible(int visible) {
+#if defined(WAPI_DXGI)
+    gfx_dxgi_set_cursor_visibility(visible);
+#elif defined(CAPI_SDL1) || defined(CAPI_SDL2)
+    SDL_ShowCursor(visible ? SDL_ENABLE : SDL_DISABLE);
+#endif
+}
+
+void controller_mouse_set_visible(void) {
+    if (configWindow.fullscreen) {
+        controller_mouse_is_visible(false);
+    } else {
+        controller_mouse_is_visible(!mouse_has_current_control);
+    }
+}
+
+int controller_mouse_set_position(void *cursorX, void *cursorY, f32 mPosX, f32 mPosY, int hasControlCondition, int isInteger) {
+    // Disable control is mouse config is off
+    if (!configMouse) {
+        return FALSE;
+    }
+
+    // Disable mouse control if condition isn't met 
+    if (!hasControlCondition) {
+        mouse_has_current_control = FALSE;
+    }
+
+    // Check if the mouse moved and update control status if condition is met
+    if ((mouse_window_x - mouse_prev_window_x != 0 || mouse_window_y - mouse_prev_window_y != 0) && hasControlCondition) {
+        mouse_has_current_control = TRUE;
+    }
+
+    // Scale calculations and cursor position update if the mouse has control
+    if (configMouse && mouse_has_current_control) {
+        float posX = mPosX;
+        float posY = mPosY;
+
+        // Update position based on type
+        if (isInteger) { // Mario Head cursor
+            *(s32*)cursorX = (s32)posX;
+            *(s32*)cursorY = (s32)posY;
+        } else { // Float, File select cursor
+            *(float*)cursorX = posX;
+            *(float*)cursorY = posY;
+        }
+    }
+
+    // Make the controller mouse visible and update the previous mouse position
+    controller_mouse_set_visible();
+    mouse_prev_window_x = mouse_window_x;
+    mouse_prev_window_y = mouse_window_y;
+
+    return mouse_has_current_control;
+}
+
+void controller_mouse_read_window(void) {
+    if (!mouse_init_ok) { return; }
+
+#if defined(WAPI_DXGI)
+    HWND game_window = gfx_dxgi_get_h_wnd();
+
+    mouse_window_buttons = controller_mouse_dxgi_button_state(
+        &mouse_window_buttons_held_on_focus,
+        GetFocus() == game_window);
+
+    POINT p;
+    if (GetCursorPos(&p) && ScreenToClient(game_window, &p)) {
+        mouse_window_x = p.x;
+        mouse_window_y = p.y;
+    }
+#elif defined(CAPI_SDL1) || defined(CAPI_SDL2)
+    mouse_window_buttons = SDL_GetMouseState(&mouse_window_x, &mouse_window_y);
+#endif
+}
+
+void controller_mouse_read_relative(void) {
+    if (!mouse_init_ok) { return; }
+
+#if defined(WAPI_DXGI)
+    HWND game_window = gfx_dxgi_get_h_wnd();
+
+    // Always get the buttons state, regardless if the relative mode is enabled.
+    mouse_buttons = controller_mouse_dxgi_button_state(
+        &mouse_relative_buttons_held_on_focus,
+        GetFocus() == game_window);
+
+    if (mouse_relative_enabled) {
+        static POINT p0;
+        POINT p1;
+        RECT rect;
+        if (GetWindowRect(gfx_dxgi_get_h_wnd(), &rect) && GetCursorPos(&p1)) {
+            mouse_x = p1.x - p0.x;
+            mouse_y = p1.y - p0.y;
+
+            p0.x = rect.left + (rect.right - rect.left) / 2;
+            p0.y = rect.top + (rect.bottom - rect.top) / 2;
+            ClipCursor(&rect); // Prevents visible mouse if you move it too fast 
+            SetCursorPos(p0.x, p0.y);
+        }
+    } else {
+        ClipCursor(NULL);
+        mouse_x = 0;
+        mouse_y = 0;
+    }
+
+#elif defined(CAPI_SDL1) || defined(CAPI_SDL2)
+    mouse_buttons = SDL_GetRelativeMouseState(&mouse_x, &mouse_y);
+#endif
+}
+
+void controller_mouse_enter_relative(void) {
+    if (!mouse_relative_enabled) {
+        mouse_relative_enabled = true;
+
+#if defined(WAPI_DXGI)
+        gfx_dxgi_set_cursor_visibility(false);
+#elif defined(CAPI_SDL1)
+        SDL_WM_GrabInput(SDL_GRAB_ON);
+#elif defined(CAPI_SDL2)
+        SDL_SetRelativeMouseMode(SDL_TRUE);
+#endif
+    }
+}
+
+void controller_mouse_leave_relative(void) {
+    if (mouse_relative_enabled) {
+        mouse_relative_enabled = false;
+
+#if defined(WAPI_DXGI)
+        gfx_dxgi_set_cursor_visibility(configWindow.fullscreen ? FALSE : TRUE);
+#elif defined(CAPI_SDL1)
+        SDL_WM_GrabInput(SDL_GRAB_OFF);
+#elif defined(CAPI_SDL2)
+        SDL_SetRelativeMouseMode(SDL_FALSE);
+#endif
+    }
+}
diff --git a/src/pc/controller/controller_mouse.h b/src/pc/controller/controller_mouse.h
index 422143ce6..bec816817 100644
--- a/src/pc/controller/controller_mouse.h
+++ b/src/pc/controller/controller_mouse.h
@@ -3,15 +3,33 @@
 
 #include "controller_api.h"
 #include "pc/gfx/gfx_pc.h"
+#include <stdbool.h>
 
-extern int gMouseXPos;
-extern int gMouseYPos;
-extern int gOldMouseXPos;
-extern int gOldMouseYPos;
-extern int gMouseHasFreeControl;
-extern int gMouseHasCenterControl;
+extern bool mouse_init_ok;
+
+extern u32 mouse_buttons;
+extern s32 mouse_x;
+extern s32 mouse_y;
+
+extern u32 mouse_window_buttons;
+extern s32 mouse_window_x;
+extern s32 mouse_window_y;
+
+extern bool mouse_relative_enabled;
+
+extern int mouse_prev_window_x;
+extern int mouse_prev_window_y;
+extern int mouse_has_current_control;
+extern int mouse_has_center_control;
+
+void controller_mouse_set_visible(void);
+int controller_mouse_set_position(void *cursorX, void *cursorY, f32 mPosX, f32 mPosY, int hasControlCondition, int isInteger);
+void controller_mouse_read_window(void);
+void controller_mouse_read_relative(void);
+
+void controller_mouse_enter_relative(void);
+void controller_mouse_leave_relative(void);
 
-#define VK_BASE_MOUSE 0x2000
 
 extern struct ControllerAPI controller_mouse;
 
diff --git a/src/pc/controller/controller_sdl1.c b/src/pc/controller/controller_sdl1.c
index 1593ad65f..750d904ab 100644
--- a/src/pc/controller/controller_sdl1.c
+++ b/src/pc/controller/controller_sdl1.c
@@ -38,15 +38,6 @@ enum {
     MAX_AXES,
 };
 
-#ifdef MOUSE_ACTIONS
-int gMouseXPos;
-int gMouseYPos;
-int gOldMouseXPos;
-int gOldMouseYPos;
-int gMouseHasFreeControl;
-int gMouseHasCenterControl;
-#endif
-
 static bool init_ok;
 static SDL_Joystick *sdl_joy;
 
@@ -128,9 +119,17 @@ static void controller_sdl_init(void) {
                 joy_axis_binds[i] = -1;
     }
 
+#ifdef MOUSE_ACTIONS
+    if (mouse_has_center_control && sCurrPlayMode != 2) {
+        controller_mouse_enter_relative();
+    }
+    controller_mouse_leave_relative();
+#endif
+
     controller_sdl_bind();
 
     init_ok = true;
+    mouse_init_ok = true;
 }
 
 static inline void update_button(const int i, const bool new) {
@@ -147,39 +146,27 @@ static inline int16_t get_axis(const int i) {
 }
 
 #ifdef MOUSE_ACTIONS
-void set_cursor_visibility(bool newVisibility) {
-    if (last_cursor_status != newVisibility) {
-        SDL_ShowCursor(newVisibility ? SDL_DISABLE : SDL_ENABLE);
-        last_cursor_status = newVisibility;
-    }
-}
-
 static void mouse_control_handler(OSContPad *pad) {
-    u32 mouse;
-
-    if (configMouse) {
-        set_cursor_visibility(gMouseHasFreeControl || configWindow.fullscreen);
-
-        if (gMouseHasCenterControl && sCurrPlayMode != 2) {
-            SDL_WM_GrabInput(SDL_GRAB_ON);
-            mouse = SDL_GetRelativeMouseState(&gMouseXPos, &gMouseYPos);
-        } else {
-            SDL_WM_GrabInput(SDL_GRAB_OFF);
-            mouse = SDL_GetMouseState(&gMouseXPos, &gMouseYPos);
-        }
+    if (!configMouse) {
+        return;
+    }
+    
+    if (mouse_has_center_control && sCurrPlayMode != 2) {
+        controller_mouse_enter_relative();
     } else {
-        set_cursor_visibility(false);
-        SDL_WM_GrabInput(SDL_GRAB_OFF);
-        mouse = SDL_GetMouseState(&gMouseXPos, &gMouseYPos);
+        controller_mouse_leave_relative();
     }
 
+    u32 mouse_prev = mouse_buttons;
+    controller_mouse_read_relative();
+    u32 mouse = mouse_buttons;
+
     for (u32 i = 0; i < num_mouse_binds; ++i)
         if (mouse & SDL_BUTTON(mouse_binds[i][0]))
             pad->button |= mouse_binds[i][1];
 
     // remember buttons that changed from 0 to 1
-    last_mouse = (mouse_buttons ^ mouse) & mouse;
-    mouse_buttons = mouse;
+    last_mouse = (mouse_prev ^ mouse) & mouse;
 }
 #endif
 
@@ -307,6 +294,7 @@ static void controller_sdl_shutdown(void) {
     }
 
     init_ok = false;
+    mouse_init_ok = false;
 }
 
 struct ControllerAPI controller_sdl = {
diff --git a/src/pc/controller/controller_sdl2.c b/src/pc/controller/controller_sdl2.c
index 256ad30fa..6cd8f0835 100644
--- a/src/pc/controller/controller_sdl2.c
+++ b/src/pc/controller/controller_sdl2.c
@@ -21,6 +21,10 @@
 #include "controller_touchscreen.h"
 #endif
 
+#ifdef MOUSE_ACTIONS
+#include "controller_mouse.h"
+#endif
+
 #include "game/level_update.h"
 
 // mouse buttons are also in the controller namespace (why), just offset 0x100
@@ -31,15 +35,6 @@
 #define MAX_JOYBUTTONS 32  // arbitrary; includes virtual keys for triggers
 #define AXIS_THRESHOLD (30 * 256)
 
-#ifdef MOUSE_ACTIONS
-int gMouseXPos;
-int gMouseYPos;
-int gOldMouseXPos;
-int gOldMouseYPos;
-int gMouseHasFreeControl;
-int gMouseHasCenterControl;
-#endif
-
 static bool init_ok;
 static bool haptics_enabled;
 static SDL_GameController *sdl_cntrl;
@@ -53,9 +48,7 @@ static u32 last_joybutton = VK_INVALID;
 #ifdef MOUSE_ACTIONS
 static u32 mouse_binds[MAX_JOYBINDS][2];
 static u32 num_mouse_binds = 0;
-static u32 mouse_buttons = 0;
 static u32 last_mouse = VK_INVALID;
-bool last_cursor_status = false;
 #endif
 
 static inline void controller_add_binds(const u32 mask, const u32 *btns) {
@@ -124,9 +117,17 @@ static void controller_sdl_init(void) {
 
     haptics_enabled = (SDL_InitSubSystem(SDL_INIT_HAPTIC) == 0);
 
+#ifdef MOUSE_ACTIONS
+    if (mouse_has_center_control && sCurrPlayMode != 2) {
+        controller_mouse_enter_relative();
+    }
+    controller_mouse_leave_relative();
+#endif
+
     controller_sdl_bind();
 
     init_ok = true;
+    mouse_init_ok = true;
 }
 
 static SDL_Haptic *controller_sdl_init_haptics(const int joy) {
@@ -156,39 +157,27 @@ static inline void update_button(const int i, const bool new) {
 }
 
 #ifdef MOUSE_ACTIONS
-void set_cursor_visibility(bool newVisibility) {
-    if (last_cursor_status != newVisibility) {
-        SDL_ShowCursor(newVisibility ? SDL_DISABLE : SDL_ENABLE);
-        last_cursor_status = newVisibility;
-    }
-}
-
 static void mouse_control_handler(OSContPad *pad) {
-    u32 mouse;
-
-    if (configMouse) {
-        set_cursor_visibility(gMouseHasFreeControl || configWindow.fullscreen);
-
-        if (gMouseHasCenterControl && sCurrPlayMode != 2) {
-            SDL_SetRelativeMouseMode(SDL_TRUE);
-            mouse = SDL_GetRelativeMouseState(&gMouseXPos, &gMouseYPos);
-        } else {
-            SDL_SetRelativeMouseMode(SDL_FALSE);
-            mouse = SDL_GetMouseState(&gMouseXPos, &gMouseYPos);
-        }
+    if (!configMouse) {
+        return;
+    }
+    
+    if (mouse_has_center_control && sCurrPlayMode != 2) {
+        controller_mouse_enter_relative();
     } else {
-        set_cursor_visibility(false);
-        SDL_SetRelativeMouseMode(SDL_FALSE);
-        mouse = SDL_GetMouseState(&gMouseXPos, &gMouseYPos);
+        controller_mouse_leave_relative();
     }
 
+    u32 mouse_prev = mouse_buttons;
+    controller_mouse_read_relative();
+    u32 mouse = mouse_buttons;
+
     for (u32 i = 0; i < num_mouse_binds; ++i)
         if (mouse & SDL_BUTTON(mouse_binds[i][0]))
             pad->button |= mouse_binds[i][1];
 
     // remember buttons that changed from 0 to 1
-    last_mouse = (mouse_buttons ^ mouse) & mouse;
-    mouse_buttons = mouse;
+    last_mouse = (mouse_prev ^ mouse) & mouse;
 }
 #endif
 
@@ -350,6 +339,7 @@ static void controller_sdl_shutdown(void) {
 
     haptics_enabled = false;
     init_ok = false;
+    mouse_init_ok = false;
 }
 
 struct ControllerAPI controller_sdl = {
diff --git a/src/pc/gfx/gfx_dxgi.cpp b/src/pc/gfx/gfx_dxgi.cpp
index f1890a69f..7d51ba802 100644
--- a/src/pc/gfx/gfx_dxgi.cpp
+++ b/src/pc/gfx/gfx_dxgi.cpp
@@ -157,6 +157,32 @@ static bool gfx_dxgi_is_window_maximized(void) {
     return window_placement.showCmd == SW_SHOWMAXIMIZED;
 }
 
+extern "C" void gfx_dxgi_set_cursor_visibility(bool visible) {
+    // https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showcursor
+    // https://devblogs.microsoft.com/oldnewthing/20091217-00/?p=15643
+    // ShowCursor uses a counter, not a boolean value, and increments or decrements that value when called
+    // This means we need to keep calling it until we get the value we want
+
+    //
+    //  NOTE:  If you continue calling until you "get the value you want" and there is no mouse attached,
+    //  it will lock the software up.  Windows always returns -1 if there is no mouse!
+    //
+
+    const int _MAX_TRIES = 15; // Prevent spinning infinitely if no mouse is plugged in
+
+    int cursorVisibilityTries = 0;
+    int cursorVisibilityCounter;
+    if (visible) {
+        do {
+            cursorVisibilityCounter = ShowCursor(true);
+        } while (cursorVisibilityCounter < 0 && ++cursorVisibilityTries < _MAX_TRIES);
+    } else {
+        do {
+            cursorVisibilityCounter = ShowCursor(false);
+        } while (cursorVisibilityCounter >= 0);
+    }
+}
+
 static void toggle_borderless_window_full_screen(bool enable) {
     // Windows 7 + flip mode + waitable object can't go to exclusive fullscreen,
     // so do borderless instead. If DWM is enabled, this means we get one monitor
@@ -183,7 +209,6 @@ static void toggle_borderless_window_full_screen(bool enable) {
             ShowWindow(dxgi.h_wnd, SW_RESTORE);
         }
         configWindow.exiting_fullscreen = false;
-        //ShowCursor(TRUE);
     } else {
         dxgi.is_full_screen = true; // Call this early so it doesn't get called twice
 
@@ -207,8 +232,6 @@ static void toggle_borderless_window_full_screen(bool enable) {
         // Set borderless full screen to that monitor
         SetWindowLongPtr(dxgi.h_wnd, GWL_STYLE, WS_VISIBLE | WS_POPUP);
         SetWindowPos(dxgi.h_wnd, HWND_TOP, r.left, r.top, r.right - r.left, r.bottom - r.top, SWP_FRAMECHANGED);
-
-        //ShowCursor(FALSE);
     }
 }
 
@@ -235,8 +258,10 @@ static void gfx_dxgi_set_fullscreen(void) {
         return;
     if (configWindow.fullscreen) {
         toggle_borderless_window_full_screen(true);
+        gfx_dxgi_set_cursor_visibility(false);
     } else {
         toggle_borderless_window_full_screen(false);
+        gfx_dxgi_set_cursor_visibility(true);
     }
 }
 
@@ -657,7 +682,7 @@ ComPtr<IDXGISwapChain1> gfx_dxgi_create_swap_chain(IUnknown *device) {
     return dxgi.swap_chain;
 }
 
-HWND gfx_dxgi_get_h_wnd(void) {
+extern "C" HWND gfx_dxgi_get_h_wnd(void) {
     return dxgi.h_wnd;
 }
 
diff --git a/src/pc/gfx/gfx_dxgi.h b/src/pc/gfx/gfx_dxgi.h
index 6f42474c3..1c16cb122 100644
--- a/src/pc/gfx/gfx_dxgi.h
+++ b/src/pc/gfx/gfx_dxgi.h
@@ -6,7 +6,8 @@
 #ifdef DECLARE_GFX_DXGI_FUNCTIONS
 void gfx_dxgi_create_factory_and_device(bool debug, int d3d_version, bool (*create_device_fn)(IDXGIAdapter1 *adapter, bool test_only));
 Microsoft::WRL::ComPtr<IDXGISwapChain1> gfx_dxgi_create_swap_chain(IUnknown *device);
-HWND gfx_dxgi_get_h_wnd(void);
+extern "C" void gfx_dxgi_set_cursor_visibility(bool visible);
+extern "C" HWND gfx_dxgi_get_h_wnd(void);
 void ThrowIfFailed(HRESULT res);
 void ThrowIfFailed(HRESULT res, HWND h_wnd, const char *message);
 #endif

From afb7cd062afe71d6d03b590bf02ceda3ffc1fa49 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Sat, 23 Nov 2024 00:54:14 -0500
Subject: [PATCH 05/15] Some small fixes

Use const on optmenu_draw_text, some people experience crashes there

Fix macro objects after refactored respawn code

Sanity check to reset sound mode to stereo with shifted saves
---
 src/extras/options_menu.c        |  4 ++--
 src/game/macro_special_objects.c | 20 +++++++++++++-------
 src/game/save_file.c             |  8 ++++++--
 3 files changed, 21 insertions(+), 11 deletions(-)

diff --git a/src/extras/options_menu.c b/src/extras/options_menu.c
index b77ad8a47..6c42de3e8 100644
--- a/src/extras/options_menu.c
+++ b/src/extras/options_menu.c
@@ -354,8 +354,8 @@ static void uint_to_hex(u32 num, u8 *dst) {
     dst[4] = DIALOG_CHAR_TERMINATOR;
 }
 
-static void optmenu_draw_text(s16 x, s16 y, const u8 str[], u8 col) {
-    u8 textX = get_str_x_pos_from_center(x, (u8 *) str, 10.0f);
+static void optmenu_draw_text(s16 x, s16 y, const u8 *str, u8 col) {
+    const u8 textX = get_str_x_pos_from_center(x, (u8 *) str, 10.0f);
     gDPSetEnvColor(gDisplayListHead++, 0, 0, 0, 255);
     print_generic_string(textX + 1, y - 1, str);
     if (col == 0) {
diff --git a/src/game/macro_special_objects.c b/src/game/macro_special_objects.c
index ba94edddc..f3ce9578b 100644
--- a/src/game/macro_special_objects.c
+++ b/src/game/macro_special_objects.c
@@ -91,7 +91,7 @@ struct LoadedMacroObject {
 UNUSED static void spawn_macro_coin_unknown(const BehaviorScript *behavior, struct LoadedMacroObject objInfo) {
     struct Object *coin;
     ModelID16 model = bhvYellowCoin == behavior ? MODEL_YELLOW_COIN : MODEL_NONE;
- 
+
     coin = spawn_object_abs_with_rot(&sMacroObjectDefaultParent, 0, model, behavior,
                                      objInfo.pos[0], objInfo.pos[1], objInfo.pos[2],
                                      0, convert_rotation(objInfo.yaw), 0);
@@ -134,9 +134,11 @@ void spawn_macro_objects(s16 areaIndex, s16 *macroObjList) {
             macroObject.params = (macroObject.params & 0xFF00) + (preset.param & 0x00FF);
         }
 
-        // Spawn the object, originally this had respawn code but
-        // since that was redone it's not necessary anymore.
-        newObj = spawn_object_abs_with_rot(
+        // If object has been killed, prevent it from respawning
+        u8 respawnInfoParam = *(u8 *)(macroObjList - 1);
+        if (respawnInfoParam != RESPAWN_INFO_DONT_RESPAWN) {
+            // Spawn the new macro object.
+            newObj = spawn_object_abs_with_rot(
                      &sMacroObjectDefaultParent,        // Parent object
                      0,                                 // Unused
                      preset.model,                      // Model ID
@@ -149,9 +151,13 @@ void spawn_macro_objects(s16 areaIndex, s16 *macroObjList) {
                      0                                  // Z-rotation
                  );
 
-        newObj->oBhvParams = ((macroObject.params & 0x00FF) << 16);
-        newObj->oBhvParams2ndByte = macroObject.params & 0x00FF;
-        newObj->parentObj = newObj;
+            newObj->oBhvParams = ((macroObject.params & 0x00FF) << 16) + (macroObject.params & 0xFF00);
+            newObj->oBhvParams2ndByte = macroObject.params & 0x00FF;
+            // Change pointers so it still uses respawn values that were originally stored in behavior params
+            newObj->respawnInfo = respawnInfoParam;
+            newObj->respawnInfoPointer = (u8 *)(macroObjList - 1);
+            newObj->parentObj = newObj;
+        }
     }
 }
 
diff --git a/src/game/save_file.c b/src/game/save_file.c
index 5792f6ffb..a8ca39bb2 100644
--- a/src/game/save_file.c
+++ b/src/game/save_file.c
@@ -720,6 +720,10 @@ void save_file_set_sound_mode(u16 mode) {
 }
 
 u16 save_file_get_sound_mode(void) {
+    // Check if the sound is in range, in case we loaded a shifted save file
+    if (gSaveBuffer.menuData[0].soundMode > 2) {
+        save_file_set_sound_mode(0); // Reset it to stereo if not
+    }
     return gSaveBuffer.menuData[0].soundMode;
 }
 
@@ -748,9 +752,9 @@ void eu_set_language(u16 language) {
 }
 
 u16 eu_get_language(void) {
-    // check if the language is in range, in case we loaded a US save with garbage padding or something
+    // Check if the language is in range, in case we loaded a non-eu save with garbage values or a shifted save
     if (gSaveBuffer.menuData[0].language >= LANGUAGE_MAX) {
-        eu_set_language(LANGUAGE_ENGLISH); // reset it to english if not
+        eu_set_language(LANGUAGE_ENGLISH); // Reset it to english if not
     }
     return gSaveBuffer.menuData[0].language;
 }

From c1ea3637824d513981b9278df222aad0a6252d61 Mon Sep 17 00:00:00 2001
From: jnack <55568980+jnackmclain@users.noreply.github.com>
Date: Sat, 23 Nov 2024 00:01:30 -0600
Subject: [PATCH 06/15] fix switch build (#67)

---
 src/pc/controller/controller_switch.c | 1 +
 src/pc/gfx/gfx_sdl2.c                 | 7 +++++--
 src/pc/pc_main.c                      | 1 +
 src/pc/platform.h                     | 1 -
 4 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/pc/controller/controller_switch.c b/src/pc/controller/controller_switch.c
index 9a2d087be..bca0d69cc 100644
--- a/src/pc/controller/controller_switch.c
+++ b/src/pc/controller/controller_switch.c
@@ -1,6 +1,7 @@
 #ifdef CAPI_SWITCH
 
 #include <switch.h>
+#include <stdlib.h>
 #include <ultra64.h>
 
 #include <sm64.h>
diff --git a/src/pc/gfx/gfx_sdl2.c b/src/pc/gfx/gfx_sdl2.c
index 98bee7b0f..7614b5c7b 100644
--- a/src/pc/gfx/gfx_sdl2.c
+++ b/src/pc/gfx/gfx_sdl2.c
@@ -45,6 +45,9 @@ void Sleep(unsigned long ms);
 #include "src/pc/controller/controller_keyboard.h"
 #include "src/pc/controller/controller_touchscreen.h"
 
+#ifdef TARGET_SWITCH
+#include <switch.h>
+#endif
 // PAL framerate things
 #ifdef VERSION_EU
 #define FRAMERATE 25
@@ -424,8 +427,8 @@ static inline void sync_framerate_with_timer(void) {
     if (frame_length < frame_rate) {
         // Only sleep if we have time to spare
         const double remain = frame_rate - frame_length;
-        // Sleep remaining time away
-        sys_sleep(remain / perf_freq * 1000000.0);
+        // Sleep remaining time away (convert remain to microseconds)
+        usleep(remain / perf_freq * 1000000.0);
         // Assume we slept the required amount of time to keep the timer stable
         frame_time = now + remain;
     } else {
diff --git a/src/pc/pc_main.c b/src/pc/pc_main.c
index d9f5564ec..9d4d4e122 100644
--- a/src/pc/pc_main.c
+++ b/src/pc/pc_main.c
@@ -48,6 +48,7 @@
 #ifdef TARGET_SWITCH
 #include "controller/controller_switch.h"
 #include "nx_main.h"
+#include <switch.h>
 #endif
 
 #include "fs/fs.h"
diff --git a/src/pc/platform.h b/src/pc/platform.h
index 0a26b461d..5408ec40c 100644
--- a/src/pc/platform.h
+++ b/src/pc/platform.h
@@ -17,7 +17,6 @@ extern const char *sys_ropaths[];
 char *sys_strdup(const char *src);
 char *sys_strlwr(char *src);
 int sys_strcasecmp(const char *s1, const char *s2);
-void sys_sleep(const uint64_t us);
 
 // path stuff
 const char *sys_user_path(void);

From d775b941deb0165344ba650b57fc86cc84f9e9a7 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Mon, 25 Nov 2024 01:10:14 -0500
Subject: [PATCH 07/15] Option menu updates and misc mario movement fixes

Limit option choice and scroll values to prevent reading invalid strings, fixes #46

Simplified drawing scroll logic and add alpha effect to draw prompt

Fix vel wall kicks, sanity check for upperWall and update walking speed fix
---
 src/extras/draw_util.c          | 16 ++++++-------
 src/extras/options_menu.c       | 32 ++++++++++++-------------
 src/game/mario_actions_moving.c |  9 ++++++--
 src/game/mario_step.c           | 41 ++++++++++++++++++++-------------
 4 files changed, 56 insertions(+), 42 deletions(-)

diff --git a/src/extras/draw_util.c b/src/extras/draw_util.c
index eaf675c31..b6dcfb04a 100644
--- a/src/extras/draw_util.c
+++ b/src/extras/draw_util.c
@@ -273,7 +273,7 @@ static void allocate_quad_vertices(Gfx *dlHead, u16 w, u16 h) {
 /******************
  * MISC RENDERING *
  ******************/
- 
+
 /**
  * Like print_generic_string but uses ASCII, then it transform it to hex.
  */
@@ -293,7 +293,7 @@ void print_generic_string_ascii(s16 x, s16 y, const char *str) {
  */
 void print_generic_string_detail(s16 x, s16 y, u8 *str, u8 r, u8 g, u8 b, u8 a, s8 hasShadow, s8 shadowPad) {
     if (hasShadow) {
-        gDPSetEnvColor(gDisplayListHead++, 0, 0, 0, 255);
+        gDPSetEnvColor(gDisplayListHead++, 0, 0, 0, a);
         print_generic_string(x + shadowPad, y - shadowPad, str);
     }
 
@@ -307,7 +307,7 @@ void print_generic_string_detail(s16 x, s16 y, u8 *str, u8 r, u8 g, u8 b, u8 a,
  */
 void print_generic_string_ascii_detail(s16 x, s16 y, const char *str, u8 r, u8 g, u8 b, u8 a, s8 hasShadow, s8 shadowPad) {
     if (hasShadow) {
-        gDPSetEnvColor(gDisplayListHead++, 0, 0, 0, 255);
+        gDPSetEnvColor(gDisplayListHead++, 0, 0, 0, a);
         print_generic_string_ascii(x + shadowPad, y - shadowPad, str);
     }
 
@@ -363,7 +363,7 @@ void print_solid_color_quad(s16 x1, s16 y1, s16 x2, s16 y2, u8 r, u8 g, u8 b, u8
  * How to render a texture rectangle:
  * First call this display list:
    gSPDisplayList(gDisplayListHead++, dl_texture_rect_ex_start);
- * 
+ *
  * Then call any print texture rectangle function depending of the texture type.
  *
  * After the texrect is render, call this display list to end if desired:
@@ -431,12 +431,12 @@ void print_texture_rectangle_ci(u8 *palette, u8 fmtPal, u8 *texture, u8 sizTex,
  * Then you set its position using create_dl_translation_matrix, like this:
    create_dl_translation_matrix(MENU_MTX_PUSH, x, y, 0.0f);
  * The x and y values can be used for positioning.
- 
+
  * Optionally you can set its rotation and scale values as well:
  * For rotation:
    create_dl_rotation_matrix(MENU_MTX_NOPUSH, r, 0, 0, 1.0f);
  * Here you only need to change the r value due to this being a 2D plane.
- 
+
  * For scale:
    create_dl_scale_matrix(MENU_MTX_NOPUSH, x, y, 1.0f);
  * The x and y values can be used for scaling.
@@ -445,11 +445,11 @@ void print_texture_rectangle_ci(u8 *palette, u8 fmtPal, u8 *texture, u8 sizTex,
  *
  * After the texrect is render, call this display list to end if desired:
    gSPDisplayList(gDisplayListHead++, dl_tri_quad_ex_end);
-   
+
  * And finally to render it to the screen, call this:
    gSPPopMatrix(gDisplayListHead++, G_MTX_MODELVIEW);
  */
- 
+
 /**
  * Prints a texture quadrangle (for RGBA16 and RGBA32) textures.
  */
diff --git a/src/extras/options_menu.c b/src/extras/options_menu.c
index 6c42de3e8..f42ec87bb 100644
--- a/src/extras/options_menu.c
+++ b/src/extras/options_menu.c
@@ -366,23 +366,23 @@ static void optmenu_draw_text(s16 x, s16 y, const u8 *str, u8 col) {
     print_generic_string(textX, y, str);
 }
 
-// TODO: Fix the hardcoded values
-static void optmenu_draw_opt_scroll(const struct Option *opt, s16 i) {
-    s16 maxvar, minvar;
-    maxvar = opt->scrMax - opt->scrMin;
-    minvar = *opt->uval - opt->scrMin;
+static void optmenu_draw_opt_scroll(const struct Option *opt, s16 y) {
+    s16 maxvar = opt->scrMax - opt->scrMin;
+    s16 minvar = *opt->uval - opt->scrMin;
+    s16 yOffset = (SCREEN_HEIGHT - y);
+    s16 xVarPos = (((f32)minvar/maxvar)*128);
 
     // Grey bar
-    print_solid_color_quad(96,111+(32*i)-(currentMenu->scroll*32),224,117+(32*i)-(currentMenu->scroll*32),0x80,0x80,0x80, 0xFF);
+    print_solid_color_quad(96, yOffset + 0, 224, yOffset + 6, 0x80, 0x80, 0x80, 0xFF);
     // White bar
-    print_solid_color_quad(96,111+(32*i)-(currentMenu->scroll*32),96+(((f32)minvar/maxvar)*128),117+(32*i)-(currentMenu->scroll*32),0xFF,0xFF,0xFF, 0xFF);
+    print_solid_color_quad(96, yOffset + 0, xVarPos + 96, yOffset + 6, 0xFF, 0xFF, 0xFF, 0xFF);
     // Red middle bar
-    print_solid_color_quad(94+(((f32)minvar/maxvar)*128),109+(32*i)-(currentMenu->scroll*32),98+(((f32)minvar/maxvar)*128),119+(32*i)-(currentMenu->scroll*32),0xFF,0x0,0x0, 0xFF);
+    print_solid_color_quad(xVarPos + 94, yOffset - 2, xVarPos + 98, yOffset + 8, 0xFF, 0x00, 0x00, 0xFF);
     // To fix strings
     gSPDisplayList(gDisplayListHead++, dl_ia_text_begin);
 }
 
-static void optmenu_draw_opt(const struct Option *opt, s16 x, s16 y, u8 sel, s16 iScrl) {
+static void optmenu_draw_opt(const struct Option *opt, s16 x, s16 y, u8 sel) {
     u8 buf[32] = { 0 };
 
     if (opt->type == OPT_SUBMENU || opt->type == OPT_BUTTON)
@@ -396,13 +396,15 @@ static void optmenu_draw_opt(const struct Option *opt, s16 x, s16 y, u8 sel, s16
             break;
 
         case OPT_CHOICE:
+            *opt->uval = CLAMP(*opt->uval, 0, opt->numChoices - 1); // Avoid reading invalid string
             optmenu_draw_text(x, y-13, opt->choices[*opt->uval], sel);
             break;
 
         case OPT_SCROLL:
+            *opt->uval = CLAMP(*opt->uval, opt->scrMin, opt->scrMax); // Avoid bar going off limits
             INT_TO_STR_DIFF(*opt->uval, buf);
             optmenu_draw_text(x, y-13, buf, sel);
-            optmenu_draw_opt_scroll(opt, iScrl);
+            optmenu_draw_opt_scroll(opt, y-11);
             break;
 
 #if !defined(TARGET_N64) && !defined(TARGET_PORT_CONSOLE)
@@ -505,8 +507,7 @@ void optmenu_draw(void) {
     print_hud_lut_string(HUD_LUT_CNDIFF, labelX, 40, currentMenu->label);
     gSPDisplayList(gDisplayListHead++, dl_rgba16_text_end);
 
-    if (currentMenu->numOpts > 4)
-    {
+    if (currentMenu->numOpts > 4) {
         print_solid_color_quad(272, 84, 280, 218, 0x80, 0x80, 0x80, 0xFF);
         scrollpos = (62)*((f32)currentMenu->scroll/(currentMenu->numOpts-4));
         print_solid_color_quad(272, 84 + scrollpos,280,156+scrollpos,0xFF,0xFF,0xFF, 0xFF);
@@ -518,7 +519,7 @@ void optmenu_draw(void) {
         scroll = 140-(32*i)+(currentMenu->scroll*32);
         // FIXME: just start from the first visible option bruh
         if (scroll <= 140 && scroll > 32)
-            optmenu_draw_opt(&currentMenu->opts[i], SCREEN_WIDTH / 2, scroll, (currentMenu->select == i), i);
+            optmenu_draw_opt(&currentMenu->opts[i], SCREEN_WIDTH / 2, scroll, (currentMenu->select == i));
     }
 
     sinpos = sins(gGlobalTimer*5000)*4;
@@ -529,7 +530,6 @@ void optmenu_draw(void) {
     gSPDisplayList(gDisplayListHead++, dl_ia_text_end);
 }
 
-
 //This has been separated for interesting reasons. Don't question it.
 void optmenu_draw_prompt(void) {
     u8 *str = (u8 *) optSmallStr[optmenu_open];
@@ -537,8 +537,8 @@ void optmenu_draw_prompt(void) {
 
     gSPDisplayList(gDisplayListHead++, dl_ia_text_begin);
 
-    print_generic_string_detail(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(57 + strW), 212, str, 255, 255, 255, 255, TRUE, 1);
-    
+    print_generic_string_detail(GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(57 + strW), 212, str, 255, 255, 255, gMenuTextAlpha, TRUE, 1);
+
     gSPDisplayList(gDisplayListHead++, dl_ia_text_end);
 }
 
diff --git a/src/game/mario_actions_moving.c b/src/game/mario_actions_moving.c
index 6df22fc2e..51795be80 100644
--- a/src/game/mario_actions_moving.c
+++ b/src/game/mario_actions_moving.c
@@ -486,8 +486,13 @@ void update_walking_speed(struct MarioState *m) {
         m->forwardVel += 1.1f;
     } else if (m->forwardVel <= targetSpeed) {
 #if FIX_INITIAL_WALKING_SPEED
-        if (m->forwardVel <= 8.0f && !mario_floor_is_slope(m)) {
-            m->forwardVel = MIN(m->intendedMag, 8.0f);
+        // When starting a walk, make a few checks and set Mario's speed to 8 on the first frame.
+        // This ensures Mario's speed is set consistently when starting a walk.
+        // We use m->actionTimer since it's set to 0 on the first frame of walking.
+        // Disable walking speed fix on vanilla demos to prevent major desyncs as well.
+        if (gCurrDemoInput == NULL && m->forwardVel <= 8.0f && m->actionTimer == 0 && !mario_floor_is_steep(m)) {
+            // Same fix as melee dashback, 8.9 vel on first frame, 5.0 when holding an object.
+            m->forwardVel = MIN(m->intendedMag, m->heldObj != NULL ? 4.0f : 8.0f);
         }
 #endif
         m->forwardVel += 1.1f - m->forwardVel / 43.0f;
diff --git a/src/game/mario_step.c b/src/game/mario_step.c
index 241878f93..7b397f10e 100644
--- a/src/game/mario_step.c
+++ b/src/game/mario_step.c
@@ -289,9 +289,6 @@ extern s32 analog_stick_held_back(struct MarioState *m);
 static s32 perform_ground_quarter_step(struct MarioState *m, Vec3f nextPos) {
 #if BETTER_RESOLVE_WALL_COLLISION
     struct WallCollisionData upperWall, lowerWall;
-    s16 i;
-    s16 wallDYaw;
-    s32 oldWallDYaw;
 #else
     UNUSED struct Surface *lowerWall;
     struct Surface *upperWall;
@@ -388,20 +385,24 @@ static s32 perform_ground_quarter_step(struct MarioState *m, Vec3f nextPos) {
     m->floorHeight = floorHeight;
 
 #if BETTER_RESOLVE_WALL_COLLISION
-    oldWallDYaw = ((m->wall != NULL) ? abs_angle_diff(atan2s(m->wall->normal.z, m->wall->normal.x), m->faceAngle[1]) : 0);
+    // Ensure there's referenced walls so it doesn't read invalid normal values
+    if (upperWall.numWalls > 0) {
+        s16 i;
+        s32 oldWallDYaw = ((m->wall != NULL) ? abs_angle_diff(atan2s(m->wall->normal.z, m->wall->normal.x), m->faceAngle[1]) : 0);
 
-    for (i = 0; i < upperWall.numWalls; i++) {
-        wallDYaw = abs_angle_diff(atan2s(upperWall.walls[i]->normal.z, upperWall.walls[i]->normal.x), m->faceAngle[1]);
-        if (wallDYaw > oldWallDYaw) {
-            oldWallDYaw = wallDYaw;
-            m->wall     = upperWall.walls[i];
-        }
+        for (i = 0; i < upperWall.numWalls; i++) {
+            s16 wallDYaw = abs_angle_diff(atan2s(upperWall.walls[i]->normal.z, upperWall.walls[i]->normal.x), m->faceAngle[1]);
+            if (wallDYaw > oldWallDYaw) {
+                oldWallDYaw = wallDYaw;
+                m->wall     = upperWall.walls[i];
+            }
 
-        if (wallDYaw >= 0x2AAA && wallDYaw <= 0x5555) {
-            continue;
-        }
+            if (wallDYaw >= 0x2AAA && wallDYaw <= 0x5555) {
+                continue;
+            }
 
-        return GROUND_STEP_HIT_WALL_CONTINUE_QSTEPS;
+            return GROUND_STEP_HIT_WALL_CONTINUE_QSTEPS;
+        }
     }
 #else
     if (upperWall != NULL) {
@@ -486,6 +487,10 @@ struct Surface *check_ledge_grab(struct MarioState *m, struct WallCollisionData
     s16 wallDYaw = 0x0;
     s16 oldWallDYaw = 0x0;
 
+    if (m->vel[1] > 0.0f) {
+        return NULL;
+    }
+
     // Only ledge grab if the wall displaced Mario in the opposite direction of his velocity.
     // hdot(displacement, vel).
     if ((displacementX * m->vel[0]) + (displacementZ * m->vel[2]) > 0.0f) {
@@ -583,6 +588,10 @@ u32 check_ledge_grab(struct MarioState *m, struct Surface *wall, Vec3f intendedP
     f32 displacementX = nextPos[0] - intendedPos[0];
     f32 displacementZ = nextPos[2] - intendedPos[2];
 
+    if (m->vel[1] > 0) {
+        return FALSE;
+    }
+
     // Only ledge grab if the wall displaced Mario in the opposite direction of
     // his velocity.
     if (displacementX * m->vel[0] + displacementZ * m->vel[2] > 0.0f) {
@@ -777,7 +786,7 @@ s32 perform_air_quarter_step(struct MarioState *m, Vec3f intendedPos, u32 stepAr
     // misalignment, you can activate these conditions in unexpected situations
     // Check if Mario can grab a wall.
 #if BETTER_RESOLVE_WALL_COLLISION
-    if (m->vel[1] <= 0.0f && (stepArg & AIR_STEP_CHECK_LEDGE_GRAB) && upperWall.numWalls == 0 && lowerWall.numWalls != 0) {
+    if ((stepArg & AIR_STEP_CHECK_LEDGE_GRAB) && upperWall.numWalls == 0 && lowerWall.numWalls != 0) {
         // Check if any walls are grabbable.
         grabbedWall = check_ledge_grab(m, &lowerWall, intendedPos, nextPos, ledgePos, &ledgeFloor);
         if (grabbedWall != NULL && ledgeFloor != NULL) {
@@ -796,7 +805,7 @@ s32 perform_air_quarter_step(struct MarioState *m, Vec3f intendedPos, u32 stepAr
         return stepResult;
     }
 #else
-    if (m->vel[1] <= 0.0f && (stepArg & AIR_STEP_CHECK_LEDGE_GRAB) && upperWall == NULL && lowerWall != NULL) {
+    if ((stepArg & AIR_STEP_CHECK_LEDGE_GRAB) && upperWall == NULL && lowerWall != NULL) {
         if (check_ledge_grab(m, lowerWall, intendedPos, nextPos)) {
             return AIR_STEP_GRABBED_LEDGE;
         }

From 1d0011e8fe65c789ebd61a8c8b99ad1252565d64 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Tue, 26 Nov 2024 00:07:32 -0500
Subject: [PATCH 08/15] Fix non mouse build plus comments

---
 src/pc/controller/controller_mouse.c | 18 ++++++++++++------
 1 file changed, 12 insertions(+), 6 deletions(-)

diff --git a/src/pc/controller/controller_mouse.c b/src/pc/controller/controller_mouse.c
index 8b9401317..172019ead 100644
--- a/src/pc/controller/controller_mouse.c
+++ b/src/pc/controller/controller_mouse.c
@@ -1,3 +1,6 @@
+//Improved Mouse controls with DirectX support by sm64coopdx team.
+#ifdef MOUSE_ACTIONS
+
 #include "controller_mouse.h"
 #include "../configfile.h"
 
@@ -36,6 +39,7 @@ u32 mouse_window_buttons_held_on_focus;
 bool mouse_dxgi_prev_focus;
 
 static u32 controller_mouse_dxgi_button_state(u32* mouse_held, bool has_focus) {
+    // TODO: Test extra mouse buttons if possible (VK_XBUTTON1, VK_XBUTTON2).
     u32 mouse =
         ((GetKeyState(VK_LBUTTON) < 0) ? (1 << 0) : 0) |
         ((GetKeyState(VK_MBUTTON) < 0) ? (1 << 1) : 0) |
@@ -78,22 +82,22 @@ void controller_mouse_set_visible(void) {
 }
 
 int controller_mouse_set_position(void *cursorX, void *cursorY, f32 mPosX, f32 mPosY, int hasControlCondition, int isInteger) {
-    // Disable control is mouse config is off
+    // Disable control is mouse config is off.
     if (!configMouse) {
         return FALSE;
     }
 
-    // Disable mouse control if condition isn't met 
+    // Disable mouse control if condition isn't met.
     if (!hasControlCondition) {
         mouse_has_current_control = FALSE;
     }
 
-    // Check if the mouse moved and update control status if condition is met
+    // Check if the mouse moved and update control status if condition is met.
     if ((mouse_window_x - mouse_prev_window_x != 0 || mouse_window_y - mouse_prev_window_y != 0) && hasControlCondition) {
         mouse_has_current_control = TRUE;
     }
 
-    // Scale calculations and cursor position update if the mouse has control
+    // Scale calculations and cursor position update if the mouse has control.
     if (configMouse && mouse_has_current_control) {
         float posX = mPosX;
         float posY = mPosY;
@@ -108,7 +112,7 @@ int controller_mouse_set_position(void *cursorX, void *cursorY, f32 mPosX, f32 m
         }
     }
 
-    // Make the controller mouse visible and update the previous mouse position
+    // Make the controller mouse visible and update the previous mouse position.
     controller_mouse_set_visible();
     mouse_prev_window_x = mouse_window_x;
     mouse_prev_window_y = mouse_window_y;
@@ -147,6 +151,7 @@ void controller_mouse_read_relative(void) {
         &mouse_relative_buttons_held_on_focus,
         GetFocus() == game_window);
 
+    // Force mouse position to be on the center of the window.
     if (mouse_relative_enabled) {
         static POINT p0;
         POINT p1;
@@ -157,7 +162,7 @@ void controller_mouse_read_relative(void) {
 
             p0.x = rect.left + (rect.right - rect.left) / 2;
             p0.y = rect.top + (rect.bottom - rect.top) / 2;
-            ClipCursor(&rect); // Prevents visible mouse if you move it too fast 
+            ClipCursor(&rect); // Prevents visible mouse if you move it too fast.
             SetCursorPos(p0.x, p0.y);
         }
     } else {
@@ -198,3 +203,4 @@ void controller_mouse_leave_relative(void) {
 #endif
     }
 }
+#endif

From 87e896054b5879e277b1992dbfc4739224ed9e40 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Sun, 1 Dec 2024 15:03:02 -0500
Subject: [PATCH 09/15] Fix EU port build (closes #74)

---
 src/audio/port_eu.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/audio/port_eu.c b/src/audio/port_eu.c
index 9dc8f80a2..e86b07035 100644
--- a/src/audio/port_eu.c
+++ b/src/audio/port_eu.c
@@ -1,5 +1,6 @@
 #include <ultra64.h>
 #include "internal.h"
+#include "heap.h"
 #include "load.h"
 #include "data.h"
 #include "seqplayer.h"

From 01db747024ce5fab3075405d8e3ed6eb080fc4c1 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Sun, 1 Dec 2024 19:38:57 -0500
Subject: [PATCH 10/15] Fix Wii U build for latest wut (closes #63)

---
 src/pc/controller/controller_keyboard.c |  4 ----
 src/pc/controller/controller_wiiu.c     |  5 +++--
 src/pc/gfx/gfx_gx2_window.cpp           | 11 ++---------
 3 files changed, 5 insertions(+), 15 deletions(-)

diff --git a/src/pc/controller/controller_keyboard.c b/src/pc/controller/controller_keyboard.c
index 55404f5e6..698b300f3 100644
--- a/src/pc/controller/controller_keyboard.c
+++ b/src/pc/controller/controller_keyboard.c
@@ -1,5 +1,3 @@
-#ifndef TARGET_WII_U
-
 #include <stdbool.h>
 #include <ultra64.h>
 
@@ -130,5 +128,3 @@ struct ControllerAPI controller_keyboard = {
     keyboard_bindkeys,
     keyboard_shutdown
 };
-
-#endif
diff --git a/src/pc/controller/controller_wiiu.c b/src/pc/controller/controller_wiiu.c
index cc5bd2c48..e7b54ea9f 100644
--- a/src/pc/controller/controller_wiiu.c
+++ b/src/pc/controller/controller_wiiu.c
@@ -6,6 +6,7 @@
 #include <string.h>
 
 #include <ultra64.h>
+#define OSTime N64_OSTime // WUT has it's own OSTime variable
 
 #include <vpad/input.h>
 #include <padscore/wpad.h>
@@ -135,8 +136,8 @@ static void read_wpad(OSContPad* pad) {
     bool gamepadRightStickNotSet = pad->ext_stick_x == 0 && pad->ext_stick_y == 0;
 
     if (status.extensionType == WPAD_EXT_NUNCHUK || status.extensionType == WPAD_EXT_MPLUS_NUNCHUK) {
-        uint32_t ext = status.nunchuck.hold;
-        stick = status.nunchuck.stick;
+        uint32_t ext = status.nunchuk.hold;
+        stick = status.nunchuk.stick;
         rStick = (KPADVec2D) {0.0, 0.0};
 
         if (wm & WPAD_BUTTON_A) pad->button |= A_BUTTON;
diff --git a/src/pc/gfx/gfx_gx2_window.cpp b/src/pc/gfx/gfx_gx2_window.cpp
index 9d75563ca..75f952452 100644
--- a/src/pc/gfx/gfx_gx2_window.cpp
+++ b/src/pc/gfx/gfx_gx2_window.cpp
@@ -105,13 +105,6 @@ static void gfx_gx2_window_exit_callback(void)
     _Exit(-1);
 }
 
-typedef enum _GX2AspectRatio
-{
-    GX2_ASPECT_RATIO_4_TO_3,
-    GX2_ASPECT_RATIO_16_TO_9
-}
-GX2AspectRatio;
-
 extern "C" GX2AspectRatio GX2GetSystemTVAspectRatio(void);
 
 static bool gfx_gx2_window_foreground_acquire_callback(void)
@@ -140,13 +133,13 @@ static bool gfx_gx2_window_foreground_acquire_callback(void)
         case GX2_TV_SCAN_MODE_576I:
         case GX2_TV_SCAN_MODE_480I:
         case GX2_TV_SCAN_MODE_480P:
-            if (tv_aspect_ratio == GX2_ASPECT_RATIO_4_TO_3)
+            if (tv_aspect_ratio == GX2_ASPECT_RATIO_4_3)
             {
                 g_window_width = 640;
                 g_window_height = 480;
                 tv_render_mode = GX2_TV_RENDER_MODE_STANDARD_480P;
             }
-            else // if (tv_aspect_ratio == GX2_ASPECT_RATIO_16_TO_9)
+            else // if (tv_aspect_ratio == GX2_ASPECT_RATIO_16_9)
             {
                 g_window_width = 854;
                 g_window_height = 480;

From f3e2fb56b797cad83d026ac8697b65fd8d8d8380 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Fri, 6 Dec 2024 23:24:33 -0500
Subject: [PATCH 11/15] Missed this mouse_init_ok define

---
 src/pc/controller/controller_sdl1.c | 20 +++++++++++---------
 src/pc/controller/controller_sdl2.c |  6 +++++-
 2 files changed, 16 insertions(+), 10 deletions(-)

diff --git a/src/pc/controller/controller_sdl1.c b/src/pc/controller/controller_sdl1.c
index 750d904ab..9396972be 100644
--- a/src/pc/controller/controller_sdl1.c
+++ b/src/pc/controller/controller_sdl1.c
@@ -129,7 +129,9 @@ static void controller_sdl_init(void) {
     controller_sdl_bind();
 
     init_ok = true;
+#ifdef MOUSE_ACTIONS
     mouse_init_ok = true;
+#endif
 }
 
 static inline void update_button(const int i, const bool new) {
@@ -150,7 +152,7 @@ static void mouse_control_handler(OSContPad *pad) {
     if (!configMouse) {
         return;
     }
-    
+
     if (mouse_has_center_control && sCurrPlayMode != 2) {
         controller_mouse_enter_relative();
     } else {
@@ -246,22 +248,20 @@ static void controller_sdl_read(OSContPad *pad) {
     magnitude_sq = (uint32_t)(rightx * rightx) + (uint32_t)(righty * righty);
     stickDeadzoneActual = configStickDeadzone * DEADZONE_STEP;
     if (magnitude_sq > (uint32_t)(stickDeadzoneActual * stickDeadzoneActual)) {
-        #if 0 // not used but leaving just in case
-        pad->ext_stick_x = rightx / 0x100;
-        int stick_y = -righty / 0x100;
-        pad->ext_stick_y = stick_y == 128 ? 127 : stick_y;
-        #else
         // Game expects stick coordinates within -80..80
         // 32768 / 409 = ~80
         pad->ext_stick_x = rightx / 409;
         pad->ext_stick_y = -righty / 409;
-        #endif
     }
 }
 
-static void controller_sdl_rumble_play(f32 strength, f32 length) { }
+static void controller_sdl_rumble_play(f32 strength, f32 length) {
+    // Not supported on SDL1
+}
 
-static void controller_sdl_rumble_stop(void) { }
+static void controller_sdl_rumble_stop(void) {
+    // Not supported on SDL1
+}
 
 static u32 controller_sdl_rawkey(void) {
     if (last_joybutton != VK_INVALID) {
@@ -294,7 +294,9 @@ static void controller_sdl_shutdown(void) {
     }
 
     init_ok = false;
+#ifdef MOUSE_ACTIONS
     mouse_init_ok = false;
+#endif
 }
 
 struct ControllerAPI controller_sdl = {
diff --git a/src/pc/controller/controller_sdl2.c b/src/pc/controller/controller_sdl2.c
index 6cd8f0835..58b545c73 100644
--- a/src/pc/controller/controller_sdl2.c
+++ b/src/pc/controller/controller_sdl2.c
@@ -127,7 +127,9 @@ static void controller_sdl_init(void) {
     controller_sdl_bind();
 
     init_ok = true;
+#ifdef MOUSE_ACTIONS
     mouse_init_ok = true;
+#endif
 }
 
 static SDL_Haptic *controller_sdl_init_haptics(const int joy) {
@@ -161,7 +163,7 @@ static void mouse_control_handler(OSContPad *pad) {
     if (!configMouse) {
         return;
     }
-    
+
     if (mouse_has_center_control && sCurrPlayMode != 2) {
         controller_mouse_enter_relative();
     } else {
@@ -339,7 +341,9 @@ static void controller_sdl_shutdown(void) {
 
     haptics_enabled = false;
     init_ok = false;
+#ifdef MOUSE_ACTIONS
     mouse_init_ok = false;
+#endif
 }
 
 struct ControllerAPI controller_sdl = {

From 7f01d556a74828d83a9d58e829b946e8bb9eaa38 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Wed, 18 Dec 2024 17:59:23 -0500
Subject: [PATCH 12/15] Fix audio hang and object collision without auto
 distance

---
 src/audio/heap.c          | 11 ++++++-----
 src/engine/surface_load.c | 24 +++++++++++++-----------
 2 files changed, 19 insertions(+), 16 deletions(-)

diff --git a/src/audio/heap.c b/src/audio/heap.c
index 698e15a39..2ee82a7df 100644
--- a/src/audio/heap.c
+++ b/src/audio/heap.c
@@ -1104,17 +1104,16 @@ void audio_reset_session(void)
     s32 temporaryMem;
     s32 totalMem;
     s32 wantMisc;
-#if defined(VERSION_JP) || defined(VERSION_US)
-    s32 frames;
-    s32 remainingDmas;
-#else
+#if defined(VERSION_EU) || defined(VERSION_SH) || defined(VERSION_CN)
     struct SynthesisReverb *reverb;
     struct ReverbSettingsEU *reverbSettings;
 #endif
     eu_stubbed_printf_1("Heap Reconstruct Start %x\n", gAudioResetPresetIdToLoad);
 
+    // TODO: Cleanup audio so this block of code is no longer necessary
 #if defined(VERSION_JP) || defined(VERSION_US)
     if (gAudioLoadLock != AUDIO_LOCK_UNINITIALIZED) {
+        s32 frames;
         decrease_reverb_gain();
         for (i = 0; i < gMaxSimultaneousNotes; i++) {
             if (gNotes[i].enabled && gNotes[i].adsr.state != ADSR_STATE_DISABLED) {
@@ -1155,13 +1154,15 @@ void audio_reset_session(void)
         gAudioLoadLock = AUDIO_LOCK_LOADING;
         wait_for_audio_frames(3);
 
-        remainingDmas = gCurrAudioFrameDmaCount;
+    #ifdef TARGET_N64
+        s32 remainingDmas = gCurrAudioFrameDmaCount;
         while (remainingDmas > 0) {
             for (i = 0; i < gCurrAudioFrameDmaCount; i++) {
                 if (osRecvMesg(&gCurrAudioFrameDmaQueue, NULL, OS_MESG_NOBLOCK) == 0)
                     remainingDmas--;
             }
         }
+    #endif
         gCurrAudioFrameDmaCount = 0;
 
         for (j = 0; j < NUMAIBUFFERS; j++) {
diff --git a/src/engine/surface_load.c b/src/engine/surface_load.c
index cd8f6ce38..4c05cdaf4 100644
--- a/src/engine/surface_load.c
+++ b/src/engine/surface_load.c
@@ -814,16 +814,13 @@ static TerrainData sDynamicVertices[600];
  */
 void load_object_collision_model(void) {
     struct Object* obj = gCurrentObject;
-
     TerrainData *collisionData = obj->collisionData;
-
 #if AUTO_COLLISION_DISTANCE
     f32 sqrLateralDist;
     vec3f_get_lateral_dist_squared(&obj->oPosX, &gMarioObject->oPosX, &sqrLateralDist);
-
     f32 verticalMarioDiff = (gMarioObject->oPosY - obj->oPosY);
-
     f32 colDist;
+
     if (collisionData == NULL) {
         // No collision data, so no collision distance.
         colDist = 0.0f;
@@ -836,9 +833,15 @@ void load_object_collision_model(void) {
         colDist = obj->oCollisionDistance;
     }
 #else
+    f32 marioDist = obj->oDistanceToMario;
+    // On an object's first frame, the distance is set to F32_MAX.
+    // If the distance hasn't been updated, update it now.
+    if (marioDist == F32_MAX) {
+        marioDist = dist_between_objects(obj, gMarioObject);
+    }
+
     f32 colDist = obj->oCollisionDistance;
 #endif
-
     f32 drawDist = obj->oDrawingDistance;
 
     // ex-alo change
@@ -855,16 +858,12 @@ void load_object_collision_model(void) {
         drawDist = colDist;
     }
 
-    f32 marioDist = obj->oDistanceToMario;
-
-    int isInit = (marioDist == F32_MAX);
-
 #if AUTO_COLLISION_DISTANCE
     // A value higher than 500.0f causes crashes with surfaces
     s32 inColRadius = (
            (sqrLateralDist < sqr(colDist))
         && (verticalMarioDiff > 0 || verticalMarioDiff > -colDist)
-        && (verticalMarioDiff < 0 || verticalMarioDiff < (colDist + 500.0f))
+        && (verticalMarioDiff < 0 || verticalMarioDiff < (colDist + 2000.0f))
     );
 #else
     s32 inColRadius = (marioDist < colDist);
@@ -882,11 +881,14 @@ void load_object_collision_model(void) {
         }
     }
 
+#if AUTO_COLLISION_DISTANCE
+    f32 marioDist = obj->oDistanceToMario;
     // On an object's first frame, the distance is set to F32_MAX.
     // If the distance hasn't been updated, update it now.
-    if (isInit) {
+    if (marioDist == F32_MAX) {
         marioDist = dist_between_objects(obj, gMarioObject);
     }
+#endif
 
 #ifndef NODRAWINGDISTANCE
     if (marioDist < drawDist) {

From 215aab6f48656dfe9942ca25df8fdc9f517ff5dd Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Thu, 19 Dec 2024 00:48:52 -0500
Subject: [PATCH 13/15] Some build fixes from sm64ex and SDL2 rumble fix

Make: Set CPP_ASSEMBLY on web target and additional mips cross target

Potentially fix switch build on macOS

Fix buffer overflow on skyconv using gcc 13 and glibc 2.39

Additional rumble code for later SDL2 versions
---
 Makefile                              | 10 ++++++++--
 src/pc/controller/controller_sdl2.c   | 21 +++++++++++++++++++--
 src/pc/controller/controller_switch.c |  2 +-
 tools/skyconv.c                       |  6 +++---
 4 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/Makefile b/Makefile
index 366b3f003..9379b84bd 100755
--- a/Makefile
+++ b/Makefile
@@ -162,6 +162,10 @@ ifeq ($(TARGET_PORT_CONSOLE),1)
   CPP_ASSEMBLY := 1
 endif
 
+ifeq ($(TARGET_WEB),1)
+  CPP_ASSEMBLY := 1
+endif
+
 # Custom Defines
 include defines.mk
 
@@ -805,14 +809,16 @@ ifeq ($(TARGET_N64),1)
 # detect prefix for MIPS toolchain
 ifneq ($(call find-command,mips64-elf-ld),)
   CROSS := mips64-elf-
-# else ifneq ($(call find-command,mips-n64-ld),)
-#   CROSS := mips-n64-
+else ifneq ($(call find-command,mips-n64-ld),)
+  CROSS := mips-n64-
 else ifneq ($(call find-command,mips64-ld),)
   CROSS := mips64-
 else ifneq ($(call find-command,mips-linux-gnu-ld),)
   CROSS := mips-linux-gnu-
 else ifneq ($(call find-command,mips64-linux-gnu-ld),)
   CROSS := mips64-linux-gnu-
+else ifneq ($(call find-command,mips64-none-elf-ld),)
+  CROSS := mips64-none-elf-
 else ifneq ($(call find-command,mips-ld),)
   CROSS := mips-
 else
diff --git a/src/pc/controller/controller_sdl2.c b/src/pc/controller/controller_sdl2.c
index 58b545c73..30fd3ca89 100644
--- a/src/pc/controller/controller_sdl2.c
+++ b/src/pc/controller/controller_sdl2.c
@@ -292,13 +292,30 @@ static void controller_sdl_read(OSContPad *pad) {
 }
 
 static void controller_sdl_rumble_play(f32 strength, f32 length) {
-    if (sdl_haptic)
+    if (sdl_haptic) {
         SDL_HapticRumblePlay(sdl_haptic, strength, (u32)(length * 1000.0f));
+    }
+    else {
+#if SDL_VERSION_ATLEAST(2,0,18)
+        uint16_t scaled_strength = strength * pow(2, 16) - 1;
+        if (SDL_GameControllerHasRumble(sdl_cntrl) == SDL_TRUE) {
+            SDL_GameControllerRumble(sdl_cntrl, scaled_strength, scaled_strength, (u32)(length * 1000.0f));
+        }
+#endif
+    }
 }
 
 static void controller_sdl_rumble_stop(void) {
-    if (sdl_haptic)
+    if (sdl_haptic) {
         SDL_HapticRumbleStop(sdl_haptic);
+    }
+    else {
+#if SDL_VERSION_ATLEAST(2,0,18)
+        if (SDL_GameControllerHasRumble(sdl_cntrl) == SDL_TRUE) {
+            SDL_GameControllerRumble(sdl_cntrl, 0, 0, 0);
+        }
+#endif
+    }
 }
 
 static u32 controller_sdl_rawkey(void) {
diff --git a/src/pc/controller/controller_switch.c b/src/pc/controller/controller_switch.c
index bca0d69cc..c8d6e38e3 100644
--- a/src/pc/controller/controller_switch.c
+++ b/src/pc/controller/controller_switch.c
@@ -1,8 +1,8 @@
 #ifdef CAPI_SWITCH
 
-#include <switch.h>
 #include <stdlib.h>
 #include <ultra64.h>
+#include <switch.h>
 
 #include <sm64.h>
 #include "../../game/level_update.h"
diff --git a/tools/skyconv.c b/tools/skyconv.c
index 114012cd7..36b6448fa 100644
--- a/tools/skyconv.c
+++ b/tools/skyconv.c
@@ -256,7 +256,7 @@ void write_tiles() {
     for (int i = 0; i < props.numRows * props.numCols; i++) {
         if (!tiles[i].useless) {
             *filename = 0;
-            snprintf(filename, PATH_MAX, ".%d.rgba16.png", tiles[i].pos);
+            snprintf(filename, PATH_MAX - dirLength, ".%d.rgba16.png", tiles[i].pos);
             rgba2png(buffer, tiles[i].px, props.tileWidth, props.tileHeight);
         }
     }
@@ -288,7 +288,7 @@ static void write_skybox_c() { /* write c data to disc */
         exit(EXIT_FAILURE);
     }
 
-    sprintf(fBuffer, "%s/%s_skybox.c", output, skyboxName);
+    snprintf(fBuffer, PATH_MAX, "%s/%s_skybox.c", output, skyboxName);
     cFile = fopen(fBuffer, "w"); /* reset file */
 
     /* setup C file */
@@ -647,7 +647,7 @@ int main(int argc, char *argv[]) {
             }
 
             allocate_tiles();
-            
+
             init_tiles(image, expanded);
             switch (type) {
                 case Skybox:

From cd4d1c82150fe5284183d309307ff3fb6c594886 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Thu, 19 Dec 2024 01:21:54 -0500
Subject: [PATCH 14/15] Remove no reorder surface and probably outdated comment

---
 include/config/config_collision.h |  3 ---
 src/engine/surface_load.c         | 27 ++++++++++-----------------
 2 files changed, 10 insertions(+), 20 deletions(-)

diff --git a/include/config/config_collision.h b/include/config/config_collision.h
index c36872248..c2f216e75 100644
--- a/include/config/config_collision.h
+++ b/include/config/config_collision.h
@@ -37,9 +37,6 @@
 // Saves a lot of CPU over silliness, by cleaning only used dynamic cells.
 #define BETTER_DYNAMIC_CELLS (0 || COLLISION_FIXES)
 
-// Removes surface priority ordering to save processing time.
-#define NO_SURFACE_PRIORITY_REORDER (0 || COLLISION_FIXES)
-
 // Automatically calculates the optimal collision distance for an object based on it's vertices.
 #define AUTO_COLLISION_DISTANCE (0 || QOL_FEATURES)
 
diff --git a/src/engine/surface_load.c b/src/engine/surface_load.c
index 4c05cdaf4..67985fcf0 100644
--- a/src/engine/surface_load.c
+++ b/src/engine/surface_load.c
@@ -187,16 +187,12 @@ static void add_surface_to_cell(s32 dynamic, s32 cellX, s32 cellZ, struct Surfac
         list = &gStaticSurfacePartition[cellZ][cellX][listIndex];
     }
 
-#if !NO_SURFACE_PRIORITY_REORDER || WATER_SURFACES
-#if WATER_SURFACES
-    if (listIndex == SPATIAL_PARTITION_WATER)
-#endif
+    //! (Surface Cucking) Surfaces are sorted by the height of their first vertex.
+    //  Since vertices aren't ordered by height, this causes many lower triangles
+    //  to be sorted higher. This worsens surface cucking since many functions
+    //  only use the first triangle in surface order that fits, missing higher surfaces.
+    //  upperY would be a better sort method, set with optimizations enabled.
     {
-        //! (Surface Cucking) Surfaces are sorted by the height of their first vertex.
-        //  Since vertices aren't ordered by height, this causes many lower triangles
-        //  to be sorted higher. This worsens surface cucking since many functions
-        //  only use the first triangle in surface order that fits, missing higher surfaces.
-        //  upperY would be a better sort method, set with optimizations enabled.
         s32 surfacePriority = SURFACE_SORT(surface) * sortDir;
         s32 priority;
         // Loop until we find the appropriate place for the surface in the list.
@@ -210,7 +206,7 @@ static void add_surface_to_cell(s32 dynamic, s32 cellX, s32 cellZ, struct Surfac
             list = list->next;
         }
     }
-#endif
+
     newNode->next = list->next;
     list->next = newNode;
 }
@@ -774,19 +770,17 @@ void load_object_surfaces(TerrainData **data, TerrainData *vertexData, u32 dynam
 #if AUTO_COLLISION_DISTANCE
 // From Kaze
 static f32 get_optimal_collision_distance(struct Object *obj) {
-    f32 thisVertDist, maxDist = 0.0f;
-    Vec3f thisVertPos, scale;
+    register f32 thisVertDist, maxDist = 0.0f;
+    Vec3f thisVertPos;
     TerrainData *collisionData = obj->collisionData;
     collisionData++;
-    u32 vertsLeft = *(collisionData)++;
-
-    vec3_copy(scale, obj->header.gfx.scale);
+    register u32 vertsLeft = *(collisionData)++;
 
     // Loop through the collision vertices to find the vertex
     // with the furthest distance from the model's origin.
     while (vertsLeft) {
         // Apply scale to the position
-        vec3_prod(thisVertPos, collisionData, scale);
+        vec3_prod(thisVertPos, collisionData, obj->header.gfx.scale);
 
         // Get the distance to the model's origin.
         thisVertDist = vec3_sumsq(thisVertPos);
@@ -859,7 +853,6 @@ void load_object_collision_model(void) {
     }
 
 #if AUTO_COLLISION_DISTANCE
-    // A value higher than 500.0f causes crashes with surfaces
     s32 inColRadius = (
            (sqrLateralDist < sqr(colDist))
         && (verticalMarioDiff > 0 || verticalMarioDiff > -colDist)

From 637e3bff7038020f99d2a252ab2fdaa04e098e27 Mon Sep 17 00:00:00 2001
From: AloXado320 <david.albujar.s.30@gmail.com>
Date: Thu, 9 Jan 2025 14:29:19 -0500
Subject: [PATCH 15/15] Fix steam deck external data compile (closes #79)

---
 src/pc/gfx/gfx_pc.c | 196 ++++++++++++++++++++++----------------------
 1 file changed, 98 insertions(+), 98 deletions(-)

diff --git a/src/pc/gfx/gfx_pc.c b/src/pc/gfx/gfx_pc.c
index 8bef45d65..8142764c8 100644
--- a/src/pc/gfx/gfx_pc.c
+++ b/src/pc/gfx/gfx_pc.c
@@ -83,10 +83,10 @@ struct LoadedVertex {
 
 struct TextureHashmapNode {
     struct TextureHashmapNode *next;
-    
+
     const uint8_t *texture_addr;
     uint8_t fmt, siz;
-    
+
     const uint8_t *palette;
 
     uint32_t texture_id;
@@ -113,24 +113,24 @@ static uint8_t color_combiner_pool_size;
 static struct RSP {
     float modelview_matrix_stack[11][4][4];
     uint8_t modelview_matrix_stack_size;
-    
+
     float MP_matrix[4][4];
     float P_matrix[4][4];
-    
+
     Light_t current_lights[MAX_LIGHTS + 1];
     float current_lights_coeffs[MAX_LIGHTS][3];
     float current_lookat_coeffs[2][3]; // lookat_x, lookat_y
     uint8_t current_num_lights; // includes ambient light
     bool lights_changed;
-    
+
     uint32_t geometry_mode;
     int16_t fog_mul, fog_offset;
-    
+
     struct {
         // U0.16
         uint16_t s, t;
     } texture_scaling_factor;
-    
+
     struct LoadedVertex loaded_vertices[MAX_VERTICES + 4];
 
     uint8_t saved_opcode;
@@ -158,10 +158,10 @@ static struct RDP {
         uint32_t line_size_bytes;
     } texture_tile;
     bool textures_changed[2];
-    
+
     uint32_t other_mode_l, other_mode_h;
     uint32_t combine_mode;
-    
+
     struct RGBA env_color, prim_color, fog_color, fill_color;
     struct XYWidthHeight viewport, scissor;
     bool viewport_or_scissor_changed;
@@ -317,7 +317,7 @@ static struct ColorCombiner *gfx_lookup_or_create_color_combiner(uint32_t cc_id)
     if (prev_combiner != NULL && prev_combiner->cc_id == cc_id) {
         return prev_combiner;
     }
-    
+
     for (size_t i = 0; i < color_combiner_pool_size; i++) {
         if (color_combiner_pool[i].cc_id == cc_id) {
             return prev_combiner = &color_combiner_pool[i];
@@ -392,10 +392,10 @@ static void import_texture_rgba16(int tile) {
         rgba32_buf[4*i + 2] = SCALE_5_8(b);
         rgba32_buf[4*i + 3] = a ? 255 : 0;
     }
-    
+
     uint32_t width = rdp.texture_tile.line_size_bytes / 2;
     uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
-    
+
     gfx_rapi->upload_texture(rgba32_buf, width, height);
 }
 
@@ -405,7 +405,7 @@ static void import_texture_rgba32(int tile) {
     gfx_rapi->upload_texture(rdp.loaded_texture[tile].addr, width, height);
 }
 
-static void import_texture_ia4(int tile) {   
+static void import_texture_ia4(int tile) {
     for (uint32_t i = 0; i < rdp.loaded_texture[tile].size_bytes * 2; i++) {
         uint8_t byte = rdp.loaded_texture[tile].addr[i / 2];
         uint8_t part = (byte >> (4 - (i % 2) * 4)) & 0xf;
@@ -419,14 +419,14 @@ static void import_texture_ia4(int tile) {
         rgba32_buf[4*i + 2] = SCALE_3_8(b);
         rgba32_buf[4*i + 3] = alpha ? 255 : 0;
     }
-    
+
     uint32_t width = rdp.texture_tile.line_size_bytes * 2;
     uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
-    
+
     gfx_rapi->upload_texture(rgba32_buf, width, height);
 }
 
-static void import_texture_ia8(int tile) {    
+static void import_texture_ia8(int tile) {
     for (uint32_t i = 0; i < rdp.loaded_texture[tile].size_bytes; i++) {
         uint8_t intensity = rdp.loaded_texture[tile].addr[i] >> 4;
         uint8_t alpha = rdp.loaded_texture[tile].addr[i] & 0xf;
@@ -438,10 +438,10 @@ static void import_texture_ia8(int tile) {
         rgba32_buf[4*i + 2] = SCALE_4_8(b);
         rgba32_buf[4*i + 3] = SCALE_4_8(alpha);
     }
-    
+
     uint32_t width = rdp.texture_tile.line_size_bytes;
     uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
-    
+
     gfx_rapi->upload_texture(rgba32_buf, width, height);
 }
 
@@ -457,10 +457,10 @@ static void import_texture_ia16(int tile) {
         rgba32_buf[4*i + 2] = b;
         rgba32_buf[4*i + 3] = alpha;
     }
-    
+
     uint32_t width = rdp.texture_tile.line_size_bytes / 2;
     uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
-    
+
     gfx_rapi->upload_texture(rgba32_buf, width, height);
 }
 
@@ -473,10 +473,10 @@ static void import_texture_i4(int tile) {
         rgba32_buf[4*i + 2] = SCALE_4_8(intensity);
         rgba32_buf[4*i + 3] = 255;
     }
-    
+
     uint32_t width = rdp.texture_tile.line_size_bytes * 2;
     uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
-    
+
     gfx_rapi->upload_texture(rgba32_buf, width, height);
 }
 
@@ -488,10 +488,10 @@ static void import_texture_i8(int tile) {
         rgba32_buf[4*i + 2] = intensity;
         rgba32_buf[4*i + 3] = 255;
     }
-    
+
     uint32_t width = rdp.texture_tile.line_size_bytes;
     uint32_t height = rdp.loaded_texture[tile].size_bytes / rdp.texture_tile.line_size_bytes;
-    
+
     gfx_rapi->upload_texture(rgba32_buf, width, height);
 }
 
@@ -504,7 +504,7 @@ static void import_texture_ci4(int tile) {
         for (uint32_t i = 0; i < rdp.loaded_texture[tile].size_bytes * 2; i++) {
             uint8_t byte = rdp.loaded_texture[tile].addr[i / 2];
             uint8_t idx = (byte >> (4 - (i % 2) * 4)) & 0xf;
-            
+
             uint8_t intensity = rdp.palette[idx * 2];
             uint8_t alpha = rdp.palette[idx * 2 + 1];
             uint8_t r = intensity;
@@ -519,7 +519,7 @@ static void import_texture_ci4(int tile) {
         for (uint32_t i = 0; i < rdp.loaded_texture[tile].size_bytes * 2; i++) {
             uint8_t byte = rdp.loaded_texture[tile].addr[i / 2];
             uint8_t idx = (byte >> (4 - (i % 2) * 4)) & 0xf;
-            
+
             uint16_t col16 = (rdp.palette[idx * 2] << 8) | rdp.palette[idx * 2 + 1]; // Big endian load
             uint8_t a = col16 & 1;
             uint8_t r = col16 >> 11;
@@ -583,11 +583,11 @@ static void import_texture_ci8(int tile) {
 
 static inline void load_texture(const char *fullpath) {
     int w, h;
-    u64 imgsize = 0;
+    uint64_t imgsize = 0;
 
     u8 *imgdata = fs_load_file(fullpath, &imgsize);
     if (imgdata) {
-        // TODO: implement stbi_callbacks or some shit instead of loading the whole texture
+        // TODO: implement stbi_callbacks or something instead of loading the whole texture
         u8 *data = stbi_load_from_memory(imgdata, imgsize, &w, &h, NULL, 4);
         free(imgdata);
         if (data) {
@@ -837,7 +837,7 @@ static void gfx_sp_matrix(uint8_t parameters, const int32_t *addr) {
 #else
     memcpy(matrix, addr, sizeof(matrix));
 #endif
-    
+
     if (parameters & G_MTX_PROJECTION) {
         if (parameters & G_MTX_LOAD) {
             memcpy(rsp.P_matrix, matrix, sizeof(matrix));
@@ -879,17 +879,17 @@ static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const Vtx *verti
         const Vtx_t *v = &vertices[i].v;
         const Vtx_tn *vn = &vertices[i].n;
         struct LoadedVertex *d = &rsp.loaded_vertices[dest_index];
-        
+
         float x = v->ob[0] * rsp.MP_matrix[0][0] + v->ob[1] * rsp.MP_matrix[1][0] + v->ob[2] * rsp.MP_matrix[2][0] + rsp.MP_matrix[3][0];
         float y = v->ob[0] * rsp.MP_matrix[0][1] + v->ob[1] * rsp.MP_matrix[1][1] + v->ob[2] * rsp.MP_matrix[2][1] + rsp.MP_matrix[3][1];
         float z = v->ob[0] * rsp.MP_matrix[0][2] + v->ob[1] * rsp.MP_matrix[1][2] + v->ob[2] * rsp.MP_matrix[2][2] + rsp.MP_matrix[3][2];
         float w = v->ob[0] * rsp.MP_matrix[0][3] + v->ob[1] * rsp.MP_matrix[1][3] + v->ob[2] * rsp.MP_matrix[2][3] + rsp.MP_matrix[3][3];
-        
+
         x = gfx_adjust_x_for_aspect_ratio(x);
-        
+
         short U = v->tc[0] * rsp.texture_scaling_factor.s >> 16;
         short V = v->tc[1] * rsp.texture_scaling_factor.t >> 16;
-        
+
         if (rsp.geometry_mode & G_LIGHTING) {
             if (rsp.lights_changed) {
                 for (int i = 0; i < rsp.current_num_lights - 1; i++) {
@@ -901,13 +901,13 @@ static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const Vtx *verti
                 calculate_normal_dir(&lookat_y, rsp.current_lookat_coeffs[1]);
                 rsp.lights_changed = false;
             }
-            
+
             const bool useFirstColor = (dest_index & 1) == 0;
             const unsigned char* col = useFirstColor ? rsp.current_lights[rsp.current_num_lights - 1].col : rsp.current_lights[rsp.current_num_lights - 1].colc;
             int r = col[0];
             int g = col[1];
             int b = col[2];
-            
+
             for (int i = 0; i < rsp.current_num_lights - 1; i++) {
                 float intensity = 0;
                 intensity += vn->n[0] * rsp.current_lights_coeffs[i][0];
@@ -921,11 +921,11 @@ static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const Vtx *verti
                     b += intensity * col[2];
                 }
             }
-            
+
             d->color.r = r > 255 ? 255 : r;
             d->color.g = g > 255 ? 255 : g;
             d->color.b = b > 255 ? 255 : b;
-            
+
             if (rsp.geometry_mode & G_TEXTURE_GEN) {
                 float dotx = 0, doty = 0;
                 dotx += vn->n[0] * rsp.current_lookat_coeffs[0][0];
@@ -934,7 +934,7 @@ static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const Vtx *verti
                 doty += vn->n[0] * rsp.current_lookat_coeffs[1][0];
                 doty += vn->n[1] * rsp.current_lookat_coeffs[1][1];
                 doty += vn->n[2] * rsp.current_lookat_coeffs[1][2];
-                
+
                 U = (int32_t)((dotx / 127.0f + 1.0f) / 4.0f * rsp.texture_scaling_factor.s);
                 V = (int32_t)((doty / 127.0f + 1.0f) / 4.0f * rsp.texture_scaling_factor.t);
             }
@@ -943,10 +943,10 @@ static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const Vtx *verti
             d->color.g = v->cn[1];
             d->color.b = v->cn[2];
         }
-        
+
         d->u = U;
         d->v = V;
-        
+
         // trivial clip rejection
         d->clip_rej = 0;
 #ifdef TARGET_N3DS
@@ -971,23 +971,23 @@ static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const Vtx *verti
 #endif
         if (z < -w) d->clip_rej |= 16;
         if (z > w) d->clip_rej |= 32;
-        
+
         d->x = x;
         d->y = y;
         d->z = z;
         d->w = w;
-        
+
         if (rsp.geometry_mode & G_FOG) {
             if (fabsf(w) < 0.001f) {
                 // To avoid division by zero
                 w = 0.001f;
             }
-            
+
             float winv = 1.0f / w;
             if (winv < 0.0f) {
                 winv = 32767.0f;
             }
-            
+
             float fog_z = z * winv * rsp.fog_mul + rsp.fog_offset;
             if (fog_z < 0) fog_z = 0;
             if (fog_z > 255) fog_z = 255;
@@ -1003,27 +1003,27 @@ static void gfx_sp_tri1(uint8_t vtx1_idx, uint8_t vtx2_idx, uint8_t vtx3_idx) {
     struct LoadedVertex *v2 = &rsp.loaded_vertices[vtx2_idx];
     struct LoadedVertex *v3 = &rsp.loaded_vertices[vtx3_idx];
     struct LoadedVertex *v_arr[3] = {v1, v2, v3};
-    
+
     //if (rand()%2) return;
-    
+
     if (v1->clip_rej & v2->clip_rej & v3->clip_rej) {
         // The whole triangle lies outside the visible area
         return;
     }
-    
+
     if ((rsp.geometry_mode & G_CULL_BOTH) != 0) {
         float dx1 = v1->x / (v1->w) - v2->x / (v2->w);
         float dy1 = v1->y / (v1->w) - v2->y / (v2->w);
         float dx2 = v3->x / (v3->w) - v2->x / (v2->w);
         float dy2 = v3->y / (v3->w) - v2->y / (v2->w);
         float cross = dx1 * dy2 - dy1 * dx2;
-        
+
         if ((v1->w < 0) ^ (v2->w < 0) ^ (v3->w < 0)) {
             // If one vertex lies behind the eye, negating cross will give the correct result.
             // If all vertices lie behind the eye, the triangle will be rejected anyway.
             cross = -cross;
         }
-        
+
         switch (rsp.geometry_mode & G_CULL_BOTH) {
             case G_CULL_FRONT:
                 if (cross <= 0) return;
@@ -1036,28 +1036,28 @@ static void gfx_sp_tri1(uint8_t vtx1_idx, uint8_t vtx2_idx, uint8_t vtx3_idx) {
                 return;
         }
     }
-    
+
     bool depth_test = (rsp.geometry_mode & G_ZBUFFER) == G_ZBUFFER;
     if (depth_test != rendering_state.depth_test) {
         gfx_flush();
         gfx_rapi->set_depth_test(depth_test);
         rendering_state.depth_test = depth_test;
     }
-    
+
     bool z_upd = (rdp.other_mode_l & Z_UPD) == Z_UPD;
     if (z_upd != rendering_state.depth_mask) {
         gfx_flush();
         gfx_rapi->set_depth_mask(z_upd);
         rendering_state.depth_mask = z_upd;
     }
-    
+
     bool zmode_decal = (rdp.other_mode_l & ZMODE_DEC) == ZMODE_DEC;
     if (zmode_decal != rendering_state.decal_mode) {
         gfx_flush();
         gfx_rapi->set_zmode_decal(zmode_decal);
         rendering_state.decal_mode = zmode_decal;
     }
-    
+
     if (rdp.viewport_or_scissor_changed) {
         if (memcmp(&rdp.viewport, &rendering_state.viewport, sizeof(rdp.viewport)) != 0) {
             gfx_flush();
@@ -1071,27 +1071,27 @@ static void gfx_sp_tri1(uint8_t vtx1_idx, uint8_t vtx2_idx, uint8_t vtx3_idx) {
         }
         rdp.viewport_or_scissor_changed = false;
     }
-    
+
     uint32_t cc_id = rdp.combine_mode;
-    
+
     bool use_alpha = (rdp.other_mode_l & (G_BL_A_MEM << 18)) == 0;
     bool use_fog = (rdp.other_mode_l >> 30) == G_BL_CLR_FOG;
     bool texture_edge = (rdp.other_mode_l & CVG_X_ALPHA) == CVG_X_ALPHA;
     bool use_noise = (rdp.other_mode_l & G_AC_DITHER) == G_AC_DITHER;
-    
+
     if (texture_edge) {
         use_alpha = true;
     }
-    
+
     if (use_alpha) cc_id |= SHADER_OPT_ALPHA;
     if (use_fog) cc_id |= SHADER_OPT_FOG;
     if (texture_edge) cc_id |= SHADER_OPT_TEXTURE_EDGE;
     if (use_noise) cc_id |= SHADER_OPT_NOISE;
-    
+
     if (!use_alpha) {
         cc_id &= ~0xfff000;
     }
-    
+
     struct ColorCombiner *comb = gfx_lookup_or_create_color_combiner(cc_id);
     struct ShaderProgram *prg = comb->prg;
     if (prg != rendering_state.shader_program) {
@@ -1108,7 +1108,7 @@ static void gfx_sp_tri1(uint8_t vtx1_idx, uint8_t vtx2_idx, uint8_t vtx3_idx) {
     uint8_t num_inputs;
     bool used_textures[2];
     gfx_rapi->shader_get_info(prg, &num_inputs, used_textures);
-    
+
     for (int i = 0; i < 2; i++) {
         if (used_textures[i]) {
             if (rdp.textures_changed[i]) {
@@ -1126,13 +1126,13 @@ static void gfx_sp_tri1(uint8_t vtx1_idx, uint8_t vtx2_idx, uint8_t vtx3_idx) {
             }
         }
     }
-    
+
     bool use_texture = used_textures[0] || used_textures[1];
     uint32_t tex_width = (rdp.texture_tile.lrs - rdp.texture_tile.uls + 4) / 4;
     uint32_t tex_height = (rdp.texture_tile.lrt - rdp.texture_tile.ult + 4) / 4;
-    
+
     bool z_is_from_0_to_1 = gfx_rapi->z_is_from_0_to_1();
-    
+
     for (int i = 0; i < 3; i++) {
         float z = v_arr[i]->z, w = v_arr[i]->w;
         if (z_is_from_0_to_1) {
@@ -1147,7 +1147,7 @@ static void gfx_sp_tri1(uint8_t vtx1_idx, uint8_t vtx2_idx, uint8_t vtx3_idx) {
         buf_vbo[buf_vbo_len++] = z;
 #endif
         buf_vbo[buf_vbo_len++] = w;
-        
+
         if (use_texture) {
             float u = (v_arr[i]->u - rdp.texture_tile.uls * 8) / 32.0f;
             float v = (v_arr[i]->v - rdp.texture_tile.ult * 8) / 32.0f;
@@ -1171,7 +1171,7 @@ static void gfx_sp_tri1(uint8_t vtx1_idx, uint8_t vtx2_idx, uint8_t vtx3_idx) {
             buf_vbo[buf_vbo_len++] = rdp.fog_color.b / 255.0f;
             buf_vbo[buf_vbo_len++] = v_arr[i]->color.a / 255.0f; // fog factor (not alpha)
         }
-#endif     
+#endif
         for (int j = 0; j < num_inputs; j++) {
             struct RGBA *color;
             struct RGBA tmp;
@@ -1241,17 +1241,17 @@ static void gfx_calc_and_set_viewport(const Vp_t *viewport) {
     float height = 2.0f * viewport->vscale[1] / 4.0f;
     float x = (viewport->vtrans[0] / 4.0f) - width / 2.0f;
     float y = SCREEN_HEIGHT - ((viewport->vtrans[1] / 4.0f) + height / 2.0f);
-    
+
     width *= RATIO_X;
     height *= RATIO_Y;
     x *= RATIO_X;
     y *= RATIO_Y;
-    
+
     rdp.viewport.x = x;
     rdp.viewport.y = y;
     rdp.viewport.width = width;
     rdp.viewport.height = height;
-    
+
     rdp.viewport_or_scissor_changed = true;
 }
 
@@ -1319,12 +1319,12 @@ static void gfx_dp_set_scissor(UNUSED uint32_t mode, uint32_t ulx, uint32_t uly,
     float y = (SCREEN_HEIGHT - lry / 4.0f) * RATIO_Y;
     float width = (lrx - ulx) / 4.0f * RATIO_X;
     float height = (lry - uly) / 4.0f * RATIO_Y;
-    
+
     rdp.scissor.x = x;
     rdp.scissor.y = y;
     rdp.scissor.width = width;
     rdp.scissor.height = height;
-    
+
     rdp.viewport_or_scissor_changed = true;
 }
 
@@ -1333,7 +1333,7 @@ static void gfx_dp_set_texture_image(UNUSED uint32_t format, uint32_t size, UNUS
     rdp.texture_to_load.siz = size;
 }
 
-static void gfx_dp_set_tile(uint8_t fmt, uint32_t siz, uint32_t line, uint32_t tmem, uint8_t tile, uint32_t palette, uint32_t cmt, 
+static void gfx_dp_set_tile(uint8_t fmt, uint32_t siz, uint32_t line, uint32_t tmem, uint8_t tile, uint32_t palette, uint32_t cmt,
                             UNUSED uint32_t maskt, UNUSED uint32_t shiftt, uint32_t cms, UNUSED uint32_t masks, UNUSED uint32_t shifts) {
     if (tile == G_TX_RENDERTILE) {
         SUPPORT_CHECK(palette == 0); // palette should set upper 4 bits of color index in 4b mode
@@ -1345,7 +1345,7 @@ static void gfx_dp_set_tile(uint8_t fmt, uint32_t siz, uint32_t line, uint32_t t
         rdp.textures_changed[0] = true;
         rdp.textures_changed[1] = true;
     }
-    
+
     if (tile == G_TX_LOADTILE) {
         rdp.texture_to_load.tile_number = tmem / 256;
     }
@@ -1372,7 +1372,7 @@ static void gfx_dp_load_block(uint8_t tile, uint32_t uls, uint32_t ult, uint32_t
     SUPPORT_CHECK(tile == G_TX_LOADTILE);
     SUPPORT_CHECK(uls == 0);
     SUPPORT_CHECK(ult == 0);
-    
+
     // The lrs field rather seems to be number of pixels to load
     uint32_t word_size_shift;
     switch (rdp.texture_to_load.siz) {
@@ -1392,7 +1392,7 @@ static void gfx_dp_load_block(uint8_t tile, uint32_t uls, uint32_t ult, uint32_t
     uint32_t size_bytes = (lrs + 1) << word_size_shift;
     rdp.loaded_texture[rdp.texture_to_load.tile_number].size_bytes = size_bytes;
     rdp.loaded_texture[rdp.texture_to_load.tile_number].addr = rdp.texture_to_load.addr;
-    
+
     rdp.textures_changed[rdp.texture_to_load.tile_number] = true;
 }
 
@@ -1501,66 +1501,66 @@ static void gfx_dp_set_fill_color(uint32_t packed_color) {
 static void gfx_draw_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t lry) {
     uint32_t saved_other_mode_h = rdp.other_mode_h;
     uint32_t cycle_type = (rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE));
-    
+
     if (cycle_type == G_CYC_COPY) {
         rdp.other_mode_h = (rdp.other_mode_h & ~(3U << G_MDSFT_TEXTFILT)) | G_TF_POINT;
     }
-    
+
     // U10.2 coordinates
     float ulxf = ulx;
     float ulyf = uly;
     float lrxf = lrx;
     float lryf = lry;
-    
+
     ulxf = ulxf / (4.0f * HALF_SCREEN_WIDTH) - 1.0f;
     ulyf = -(ulyf / (4.0f * HALF_SCREEN_HEIGHT)) + 1.0f;
     lrxf = lrxf / (4.0f * HALF_SCREEN_WIDTH) - 1.0f;
     lryf = -(lryf / (4.0f * HALF_SCREEN_HEIGHT)) + 1.0f;
-    
+
     ulxf = gfx_adjust_x_for_aspect_ratio(ulxf);
     lrxf = gfx_adjust_x_for_aspect_ratio(lrxf);
-    
+
     struct LoadedVertex* ul = &rsp.loaded_vertices[MAX_VERTICES + 0];
     struct LoadedVertex* ll = &rsp.loaded_vertices[MAX_VERTICES + 1];
     struct LoadedVertex* lr = &rsp.loaded_vertices[MAX_VERTICES + 2];
     struct LoadedVertex* ur = &rsp.loaded_vertices[MAX_VERTICES + 3];
-    
+
     ul->x = ulxf;
     ul->y = ulyf;
     ul->z = -1.0f;
     ul->w = 1.0f;
-    
+
     ll->x = ulxf;
     ll->y = lryf;
     ll->z = -1.0f;
     ll->w = 1.0f;
-    
+
     lr->x = lrxf;
     lr->y = lryf;
     lr->z = -1.0f;
     lr->w = 1.0f;
-    
+
     ur->x = lrxf;
     ur->y = ulyf;
     ur->z = -1.0f;
     ur->w = 1.0f;
-    
+
     // The coordinates for texture rectangle shall bypass the viewport setting
     struct XYWidthHeight default_viewport = {0, 0, gfx_current_dimensions.width, gfx_current_dimensions.height};
     struct XYWidthHeight viewport_saved = rdp.viewport;
     uint32_t geometry_mode_saved = rsp.geometry_mode;
-    
+
     rdp.viewport = default_viewport;
     rdp.viewport_or_scissor_changed = true;
     rsp.geometry_mode = 0;
-    
+
     gfx_sp_tri1(MAX_VERTICES + 0, MAX_VERTICES + 1, MAX_VERTICES + 3);
     gfx_sp_tri1(MAX_VERTICES + 1, MAX_VERTICES + 2, MAX_VERTICES + 3);
-    
+
     rsp.geometry_mode = geometry_mode_saved;
     rdp.viewport = viewport_saved;
     rdp.viewport_or_scissor_changed = true;
-    
+
     if (cycle_type == G_CYC_COPY) {
         rdp.other_mode_h = saved_other_mode_h;
     }
@@ -1572,15 +1572,15 @@ static void gfx_dp_texture_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int3
         // Per RDP Command Summary Set Tile's shift s and this dsdx should be set to 4 texels
         // Divide by 4 to get 1 instead
         dsdx >>= 2;
-        
+
         // Color combiner is turned off in copy mode
         gfx_dp_set_combine_mode(color_comb(0, 0, 0, G_CCMUX_TEXEL0), color_comb(0, 0, 0, G_ACMUX_TEXEL0));
-        
+
         // Per documentation one extra pixel is added in this modes to each edge
         lrx += 1 << 2;
         lry += 1 << 2;
     }
-    
+
     // uls and ult are S10.5
     // dsdx and dtdy are S5.10
     // lrx, lry, ulx, uly are U10.2
@@ -1593,7 +1593,7 @@ static void gfx_dp_texture_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int3
     int16_t height = !flip ? lry - uly : lrx - ulx;
     float lrs = ((uls << 7) + dsdx * width) >> 7;
     float lrt = ((ult << 7) + dtdy * height) >> 7;
-    
+
     struct LoadedVertex* ul = &rsp.loaded_vertices[MAX_VERTICES + 0];
     struct LoadedVertex* ll = &rsp.loaded_vertices[MAX_VERTICES + 1];
     struct LoadedVertex* lr = &rsp.loaded_vertices[MAX_VERTICES + 2];
@@ -1613,7 +1613,7 @@ static void gfx_dp_texture_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int3
         ur->u = uls;
         ur->v = lrt;
     }
-    
+
     gfx_draw_rectangle(ulx, uly, lrx, lry);
     rdp.combine_mode = saved_combine_mode;
 }
@@ -1624,18 +1624,18 @@ static void gfx_dp_fill_rectangle(int32_t ulx, int32_t uly, int32_t lrx, int32_t
         return;
     }
     uint32_t mode = (rdp.other_mode_h & (3U << G_MDSFT_CYCLETYPE));
-    
+
     if (mode == G_CYC_COPY || mode == G_CYC_FILL) {
         // Per documentation one extra pixel is added in this modes to each edge
         lrx += 1 << 2;
         lry += 1 << 2;
     }
-    
+
     for (int i = MAX_VERTICES; i < MAX_VERTICES + 4; i++) {
         struct LoadedVertex* v = &rsp.loaded_vertices[i];
         v->color = rdp.fill_color;
     }
-    
+
     uint32_t saved_combine_mode = rdp.combine_mode;
     gfx_draw_rectangle(ulx, uly, lrx, lry);
     rdp.combine_mode = saved_combine_mode;
@@ -1668,7 +1668,7 @@ static void gfx_run_dl(Gfx* cmd) {
     //int dummy = 0;
     for (;;) {
         uint32_t opcode = cmd->words.w0 >> 24;
-        
+
         switch (opcode) {
             // RSP commands:
             case G_MTX:
@@ -1817,7 +1817,7 @@ static void gfx_run_dl(Gfx* cmd) {
                         break;
                     }
                 }
-            
+
             // RDP Commands:
             case G_SETTIMG:
                 gfx_dp_set_texture_image(C0(21, 3), C0(19, 2), C0(0, 10), seg_addr(cmd->words.w1));
